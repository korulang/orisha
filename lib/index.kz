// Orisha - High-performance web framework for Koru
//
// Public API:
//   ~orisha:serve(port)     - Start server (calls abstract handler for each request)
//   ~orisha:handler         - Abstract event users implement for request handling
//   ~orisha:router(req)     - Pattern-branch router transform
//
// Example:
//   ~import "$orisha"
//
//   // Implement the handler with routing
//   ~orisha:handler = orisha:router(req: req)
//   | [GET /] _ |> response { status: 200, body: "Hello World" }
//   | [GET /users/:id] p |> response { status: 200, body: p.id }
//   | [*] _ |> response { status: 404, body: "Not Found" }
//
//   // Start the server
//   ~orisha:serve(port: 3000)
//   | shutdown s |> io.println(message: s.reason)
//   | failed f |> io.println(message: f.msg)

~import "$std/compiler"
~import "$std/io"

~std.compiler:requires {
    exe.linkLibC();
}

const std = @import("std");
const ast = @import("ast");
const Program = ast.Program;
const posix = std.posix;

// ============================================================================
// PUBLIC TYPES
// ============================================================================

pub const Request = struct {
    method: []const u8,
    path: []const u8,
    body: ?[]const u8,

    // For param extraction by router
    allocator: std.mem.Allocator,
};

pub const ServerHandle = struct {
    inner: std.net.Server,
    allocator: std.mem.Allocator,
};

pub const ConnHandle = struct {
    stream: std.net.Stream,
    allocator: std.mem.Allocator,
};

// ============================================================================
// LISTEN - Start listening on a port
// ============================================================================

~pub event listen { port: u16 }
| listening { server: *ServerHandle }
| failed { msg: []const u8 }

~proc listen {
    const allocator = std.heap.c_allocator;

    const address = std.net.Address.parseIp("0.0.0.0", port) catch {
        return .{ .failed = .{ .msg = "Invalid address" } };
    };

    const server = address.listen(.{
        .reuse_address = true,
        .kernel_backlog = 128,
    }) catch {
        return .{ .failed = .{ .msg = "Failed to listen" } };
    };

    const handle = allocator.create(ServerHandle) catch {
        return .{ .failed = .{ .msg = "Failed to allocate server handle" } };
    };
    handle.* = .{ .inner = server, .allocator = allocator };

    std.debug.print("Orisha listening on http://0.0.0.0:{}\n", .{port});
    return .{ .listening = .{ .server = handle } };
}

// ============================================================================
// ACCEPT - Accept connection and parse HTTP request
// ============================================================================

~pub event accept { server: *ServerHandle }
| request { req: *Request, conn: *ConnHandle, server: *ServerHandle }
| failed { msg: []const u8, server: *ServerHandle }

~proc accept {
    const allocator = server.allocator;

    // Accept connection
    const conn = server.inner.accept() catch {
        return .{ .failed = .{ .msg = "Accept failed", .server = server } };
    };

    // Read HTTP request
    var buffer: [4096]u8 = undefined;
    const bytes_read = conn.stream.read(&buffer) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Read failed", .server = server } };
    };

    if (bytes_read == 0) {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Empty request", .server = server } };
    }

    // Parse HTTP request line: "GET /path HTTP/1.1"
    const request_data = buffer[0..bytes_read];
    var method: []const u8 = "GET";
    var path: []const u8 = "/";

    if (std.mem.indexOf(u8, request_data, " ")) |method_end| {
        method = request_data[0..method_end];
        const after_method = request_data[method_end + 1..];
        if (std.mem.indexOf(u8, after_method, " ")) |path_end| {
            path = after_method[0..path_end];
        }
    }

    // Allocate request
    const req = allocator.create(Request) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Failed to allocate request", .server = server } };
    };
    req.* = .{
        .method = allocator.dupe(u8, method) catch method,
        .path = allocator.dupe(u8, path) catch path,
        .body = null,
        .allocator = allocator,
    };

    // Allocate connection handle
    const conn_handle = allocator.create(ConnHandle) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Failed to allocate connection", .server = server } };
    };
    conn_handle.* = .{ .stream = conn.stream, .allocator = allocator };

    return .{ .request = .{ .req = req, .conn = conn_handle, .server = server } };
}

// ============================================================================
// SEND - Send HTTP response and close connection
// ============================================================================

~pub event send { conn: *ConnHandle, status: u16, body: []const u8 }
| sent {}
| failed { msg: []const u8 }

~proc send {
    const allocator = conn.allocator;

    // Build HTTP response
    var response_buf: std.ArrayList(u8) = .empty;
    defer response_buf.deinit(allocator);

    // Status line
    const status_text = switch (status) {
        200 => "OK",
        201 => "Created",
        204 => "No Content",
        400 => "Bad Request",
        401 => "Unauthorized",
        403 => "Forbidden",
        404 => "Not Found",
        500 => "Internal Server Error",
        else => "Unknown",
    };

    response_buf.appendSlice(allocator, "HTTP/1.1 ") catch {};
    var status_buf: [3]u8 = undefined;
    _ = std.fmt.bufPrint(&status_buf, "{}", .{status}) catch {};
    response_buf.appendSlice(allocator, &status_buf) catch {};
    response_buf.appendSlice(allocator, " ") catch {};
    response_buf.appendSlice(allocator, status_text) catch {};
    response_buf.appendSlice(allocator, "\r\n") catch {};

    // Headers
    response_buf.appendSlice(allocator, "Content-Type: text/plain\r\n") catch {};
    response_buf.appendSlice(allocator, "Content-Length: ") catch {};
    var len_buf: [20]u8 = undefined;
    const len_str = std.fmt.bufPrint(&len_buf, "{}", .{body.len}) catch "0";
    response_buf.appendSlice(allocator, len_str) catch {};
    response_buf.appendSlice(allocator, "\r\nConnection: close\r\n\r\n") catch {};

    // Body
    response_buf.appendSlice(allocator, body) catch {};

    // Send
    _ = conn.stream.writeAll(response_buf.items) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Write failed" } };
    };

    conn.stream.close();
    return .{ .sent = .{} };
}

// ============================================================================
// HANDLER - Abstract event for request handling
// ============================================================================
// Users implement this to handle requests. Default returns 404.

~[abstract]pub event handler { req: *Request }
| response { status: u16, body: []const u8 }

// Default implementation - 404 for everything
~handler = response { status: 404, body: "Not Found" }

// ============================================================================
// SERVE - Main server flow (calls handler for each request)
// ============================================================================

~pub event serve { port: u16 }
| shutdown { reason: []const u8 }
| failed { msg: []const u8 }

// serve delegates to listen, then loops forever accepting requests.
// Currently only returns 'failed' if listen fails.
// 'shutdown' will be returned when graceful shutdown is implemented.
~serve = listen(port)
| listening l |> #accept_loop accept(server: l.server)
    | request r |> handler(req: r.req)
        | response res |> send(conn: r.conn, status: res.status, body: res.body)
            | sent |> @accept_loop(server: r.server)
            | failed _ |> @accept_loop(server: r.server)
    | failed f |> @accept_loop(server: f.server)
| failed f |> failed { msg: f.msg }

// ============================================================================
// ROUTER - Pattern-branch router transform
// ============================================================================
// Transforms pattern branches into dispatch logic
//
// Usage:
//   ~orisha:handler = orisha:router(req: req)
//   | [GET /] _ |> response { status: 200, body: "Hello" }
//   | [GET /users/:id] p |> response { status: 200, body: p.id }
//   | [*] _ |> response { status: 404, body: "Not Found" }

~[comptime|transform]pub event router {
    expr: Expression,
    invocation: *const Invocation,
    item: *const Item,
    program: *const Program,
    allocator: std.mem.Allocator
}
| transformed { program: *const Program }

~proc router {
    const ast_mod = @import("ast");

    // Get the flow containing this router invocation
    const flow = if (item.* == .flow)
        &item.flow
    else if (item.* == .subflow_impl and item.subflow_impl.body == .flow)
        &item.subflow_impl.body.flow
    else
        return .{ .transformed = .{ .program = program } };

    // Check if already transformed
    for (flow.invocation.annotations) |ann| {
        if (std.mem.startsWith(u8, ann, "@pass_ran")) {
            return .{ .transformed = .{ .program = program } };
        }
    }

    // Find the expr argument from the invocation
    var expr_value: []const u8 = "null";
    for (flow.invocation.args) |arg| {
        if (std.mem.eql(u8, arg.name, "expr")) {
            expr_value = arg.value;
            break;
        }
    }

    // Collect pattern branches from continuations
    var patterns: std.ArrayList([]const u8) = .empty;
    for (flow.continuations) |cont| {
        if (cont.branch.len > 0 and cont.branch[0] == '[') {
            patterns.append(allocator, cont.branch) catch unreachable;
        }
    }

    if (patterns.items.len == 0) {
        return .{ .transformed = .{ .program = program } };
    }

    std.debug.print("[ROUTER TRANSFORM] Found {} pattern branches, expr={s}\n", .{patterns.items.len, expr_value});

    // Generate unique event name from hash of patterns + location + expr
    var hash: u64 = 0;
    for (patterns.items) |p| {
        for (p) |ch| hash = hash *% 31 +% ch;
    }
    hash = hash *% 31 +% flow.location.line;
    hash = hash *% 31 +% flow.location.column;
    for (expr_value) |ch| hash = hash *% 31 +% ch;
    var name_buf: [32]u8 = undefined;
    const event_name = std.fmt.bufPrint(&name_buf, "_router_{x}", .{hash}) catch "_router_gen";

    std.debug.print("[ROUTER TRANSFORM] Generating event: {s}\n", .{event_name});

    // Parsed pattern info
    const ParsedPattern = struct {
        raw: []const u8,
        method: []const u8,
        path: []const u8,
        params: []const []const u8,
        is_catchall: bool,
    };

    // Parse all patterns
    var parsed_patterns: std.ArrayList(ParsedPattern) = .empty;
    for (patterns.items) |pattern| {
        if (std.mem.eql(u8, pattern, "[*]")) {
            parsed_patterns.append(allocator, .{
                .raw = pattern,
                .method = "*",
                .path = "*",
                .params = &.{},
                .is_catchall = true,
            }) catch unreachable;
            continue;
        }

        const inner = pattern[1 .. pattern.len - 1];
        const space_idx = std.mem.indexOf(u8, inner, " ") orelse continue;
        const method = inner[0..space_idx];
        const path = inner[space_idx + 1 ..];

        var params_list: std.ArrayList([]const u8) = .empty;
        var path_iter = std.mem.splitScalar(u8, path, '/');
        while (path_iter.next()) |segment| {
            if (segment.len > 1 and segment[0] == ':') {
                params_list.append(allocator, segment[1..]) catch unreachable;
            }
        }

        parsed_patterns.append(allocator, .{
            .raw = pattern,
            .method = method,
            .path = path,
            .params = params_list.toOwnedSlice(allocator) catch unreachable,
            .is_catchall = false,
        }) catch unreachable;
    }

    // Create branches with proper payloads based on params
    const branches = allocator.alloc(ast_mod.Branch, parsed_patterns.items.len) catch unreachable;
    for (parsed_patterns.items, 0..) |pp, i| {
        const fields = allocator.alloc(ast_mod.Field, pp.params.len) catch unreachable;
        for (pp.params, 0..) |param_name, j| {
            fields[j] = ast_mod.Field{
                .name = allocator.dupe(u8, param_name) catch unreachable,
                .type = "[]const u8",
            };
        }

        branches[i] = ast_mod.Branch{
            .name = allocator.dupe(u8, pp.raw) catch unreachable,
            .payload = ast_mod.Shape{ .fields = fields },
        };
    }

    // Create the event declaration
    const event_decl = ast_mod.EventDecl{
        .path = ast_mod.DottedPath{
            .module_qualifier = allocator.dupe(u8, program.main_module_name) catch unreachable,
            .segments = blk: {
                const segs = allocator.alloc([]const u8, 1) catch unreachable;
                segs[0] = allocator.dupe(u8, event_name) catch unreachable;
                break :blk segs;
            },
        },
        .input = ast_mod.Shape{ .fields = &.{} },
        .branches = branches,
        .is_public = false,
        .module = flow.module,
        .location = flow.location,
    };

    // Generate proc body with pattern matching logic
    var proc_body: std.ArrayList(u8) = .empty;

    var catch_all: ?*const ParsedPattern = null;

    for (parsed_patterns.items) |*pp| {
        if (pp.is_catchall) {
            catch_all = pp;
            continue;
        }

        proc_body.appendSlice(allocator, "if (std.mem.eql(u8, (") catch unreachable;
        proc_body.appendSlice(allocator, expr_value) catch unreachable;
        proc_body.appendSlice(allocator, ").method, \"") catch unreachable;
        proc_body.appendSlice(allocator, pp.method) catch unreachable;
        proc_body.appendSlice(allocator, "\")") catch unreachable;

        if (pp.params.len == 0) {
            proc_body.appendSlice(allocator, " and std.mem.eql(u8, (") catch unreachable;
            proc_body.appendSlice(allocator, expr_value) catch unreachable;
            proc_body.appendSlice(allocator, ").path, \"") catch unreachable;
            proc_body.appendSlice(allocator, pp.path) catch unreachable;
            proc_body.appendSlice(allocator, "\")) { return .{ .@\"") catch unreachable;
            proc_body.appendSlice(allocator, pp.raw) catch unreachable;
            proc_body.appendSlice(allocator, "\" = .{} }; }\n") catch unreachable;
        } else {
            var prefix_end: usize = 0;
            var path_iter = std.mem.splitScalar(u8, pp.path, '/');
            while (path_iter.next()) |seg| {
                if (seg.len > 0 and seg[0] == ':') break;
                prefix_end += seg.len + 1;
            }

            const prefix = if (prefix_end > 0) pp.path[0..prefix_end] else "/";

            proc_body.appendSlice(allocator, " and std.mem.startsWith(u8, (") catch unreachable;
            proc_body.appendSlice(allocator, expr_value) catch unreachable;
            proc_body.appendSlice(allocator, ").path, \"") catch unreachable;
            proc_body.appendSlice(allocator, prefix) catch unreachable;
            proc_body.appendSlice(allocator, "\")) {\n") catch unreachable;

            var len_buf: [10]u8 = undefined;
            const prefix_len_str = std.fmt.bufPrint(&len_buf, "{}", .{prefix.len}) catch "0";
            proc_body.appendSlice(allocator, "    const _p = (") catch unreachable;
            proc_body.appendSlice(allocator, expr_value) catch unreachable;
            proc_body.appendSlice(allocator, ").path;\n") catch unreachable;
            proc_body.appendSlice(allocator, "    const _param = if (_p.len >= ") catch unreachable;
            proc_body.appendSlice(allocator, prefix_len_str) catch unreachable;
            proc_body.appendSlice(allocator, ") _p[") catch unreachable;
            proc_body.appendSlice(allocator, prefix_len_str) catch unreachable;
            proc_body.appendSlice(allocator, "..] else \"\";\n") catch unreachable;

            proc_body.appendSlice(allocator, "    return .{ .@\"") catch unreachable;
            proc_body.appendSlice(allocator, pp.raw) catch unreachable;
            proc_body.appendSlice(allocator, "\" = .{ .") catch unreachable;
            proc_body.appendSlice(allocator, pp.params[0]) catch unreachable;
            proc_body.appendSlice(allocator, " = _param } };\n}\n") catch unreachable;
        }
    }

    const fallback = if (catch_all) |ca| ca.raw else parsed_patterns.items[0].raw;
    proc_body.appendSlice(allocator, "return .{ .@\"") catch unreachable;
    proc_body.appendSlice(allocator, fallback) catch unreachable;
    proc_body.appendSlice(allocator, "\" = .{} };") catch unreachable;

    std.debug.print("[ROUTER TRANSFORM] Generated dispatch:\n{s}\n", .{proc_body.items});

    const proc_decl = ast_mod.ProcDecl{
        .path = ast_mod.DottedPath{
            .module_qualifier = allocator.dupe(u8, program.main_module_name) catch unreachable,
            .segments = blk: {
                const segs = allocator.alloc([]const u8, 1) catch unreachable;
                segs[0] = allocator.dupe(u8, event_name) catch unreachable;
                break :blk segs;
            },
        },
        .body = proc_body.toOwnedSlice(allocator) catch unreachable,
        .module = flow.module,
        .location = flow.location,
    };

    const new_inv_annotations = allocator.alloc([]const u8, flow.invocation.annotations.len + 1) catch unreachable;
    for (flow.invocation.annotations, 0..) |ann, j| {
        new_inv_annotations[j] = ann;
    }
    new_inv_annotations[flow.invocation.annotations.len] = allocator.dupe(u8, "@pass_ran(\"transform\")") catch unreachable;

    const new_invocation = ast_mod.Invocation{
        .path = ast_mod.DottedPath{
            .module_qualifier = allocator.dupe(u8, program.main_module_name) catch unreachable,
            .segments = blk: {
                const segs = allocator.alloc([]const u8, 1) catch unreachable;
                segs[0] = allocator.dupe(u8, event_name) catch unreachable;
                break :blk segs;
            },
        },
        .args = &.{},
        .annotations = new_inv_annotations,
    };

    const transformed_flow = ast_mod.Flow{
        .invocation = new_invocation,
        .continuations = flow.continuations,
        .annotations = flow.annotations,
        .module = flow.module,
        .location = flow.location,
    };

    var new_items: std.ArrayList(ast_mod.Item) = .empty;
    new_items.append(allocator, ast_mod.Item{ .event_decl = event_decl }) catch unreachable;
    new_items.append(allocator, ast_mod.Item{ .proc_decl = proc_decl }) catch unreachable;

    for (program.items) |prog_item| {
        if (prog_item == .flow) {
            if (prog_item.flow.location.line == flow.location.line and
                prog_item.flow.location.column == flow.location.column and
                std.mem.eql(u8, prog_item.flow.location.file, flow.location.file)) {
                new_items.append(allocator, ast_mod.Item{ .flow = transformed_flow }) catch unreachable;
                continue;
            }
        }
        new_items.append(allocator, prog_item) catch unreachable;
    }

    const new_program = allocator.create(ast_mod.Program) catch unreachable;
    new_program.* = ast_mod.Program{
        .items = new_items.toOwnedSlice(allocator) catch unreachable,
        .module_annotations = program.module_annotations,
        .main_module_name = program.main_module_name,
        .allocator = allocator,
    };

    return .{ .transformed = .{ .program = new_program } };
}
