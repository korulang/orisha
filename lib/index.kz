// Orisha - High-performance web framework for Koru
//
// Public API:
//   ~orisha:serve(port)     - Start server (calls abstract handler for each request)
//   ~orisha:handler         - Abstract event users implement for request handling
//   ~orisha:router(req)     - Pattern-branch router transform
//
// Example:
//   ~import "$orisha"
//
//   // Implement the handler with routing
//   ~orisha:handler = orisha:router(req)
//   | [GET /] _ |> response { status: 200, body: "Hello World", content_type: "text/plain" }
//   | [GET /users/:id] p |> response { status: 200, body: p.id, content_type: "text/plain" }
//   | [*] _ |> response { status: 404, body: "Not Found", content_type: "text/plain" }
//
//   // Start the server
//   ~orisha:serve(port: 3000)
//   | shutdown s |> io.println(message: s.reason)
//   | failed f |> io.println(message: f.msg)

~import "$std/compiler"
~import "$std/io"

~std.compiler:requires {
    exe.linkLibC();
}

const std = @import("std");
const ast = @import("ast");
const Program = ast.Program;
const posix = std.posix;
const c = std.c;

// ============================================================================
// PUBLIC TYPES
// ============================================================================

pub const Request = struct {
    method: []const u8,
    path: []const u8,
    body: ?[]const u8,

    // For param extraction by router
    allocator: std.mem.Allocator,
};

pub const ServerHandle = struct {
    inner: std.net.Server,
    allocator: std.mem.Allocator,
};

pub const ConnHandle = struct {
    stream: std.net.Stream,
    allocator: std.mem.Allocator,
};

// ============================================================================
// LISTEN - Start listening on a port
// ============================================================================

~pub event listen { port: u16 }
| listening { server: *ServerHandle }
| failed { msg: []const u8 }

~proc listen {
    const allocator = std.heap.c_allocator;

    const address = std.net.Address.parseIp("0.0.0.0", port) catch {
        return .{ .failed = .{ .msg = "Invalid address" } };
    };

    const server = address.listen(.{
        .reuse_address = true,
        .kernel_backlog = 128,
    }) catch {
        return .{ .failed = .{ .msg = "Failed to listen" } };
    };

    const handle = allocator.create(ServerHandle) catch {
        return .{ .failed = .{ .msg = "Failed to allocate server handle" } };
    };
    handle.* = .{ .inner = server, .allocator = allocator };

    std.debug.print("Orisha listening on http://0.0.0.0:{}\n", .{port});
    return .{ .listening = .{ .server = handle } };
}

// ============================================================================
// ACCEPT - Accept connection and parse HTTP request
// ============================================================================

~pub event accept { server: *ServerHandle }
| request { req: *Request, conn: *ConnHandle, server: *ServerHandle }
| failed { msg: []const u8, server: *ServerHandle }

~proc accept {
    const allocator = server.allocator;

    // Accept connection
    const conn = server.inner.accept() catch {
        return .{ .failed = .{ .msg = "Accept failed", .server = server } };
    };

    // Read HTTP request
    var buffer: [4096]u8 = undefined;
    const bytes_read = conn.stream.read(&buffer) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Read failed", .server = server } };
    };

    if (bytes_read == 0) {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Empty request", .server = server } };
    }

    // Parse HTTP request line: "GET /path HTTP/1.1"
    const request_data = buffer[0..bytes_read];
    var method: []const u8 = "GET";
    var path: []const u8 = "/";

    if (std.mem.indexOf(u8, request_data, " ")) |method_end| {
        method = request_data[0..method_end];
        const after_method = request_data[method_end + 1..];
        if (std.mem.indexOf(u8, after_method, " ")) |path_end| {
            path = after_method[0..path_end];
        }
    }

    // Allocate request
    const req = allocator.create(Request) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Failed to allocate request", .server = server } };
    };
    req.* = .{
        .method = allocator.dupe(u8, method) catch method,
        .path = allocator.dupe(u8, path) catch path,
        .body = null,
        .allocator = allocator,
    };

    // Allocate connection handle
    const conn_handle = allocator.create(ConnHandle) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Failed to allocate connection", .server = server } };
    };
    conn_handle.* = .{ .stream = conn.stream, .allocator = allocator };

    return .{ .request = .{ .req = req, .conn = conn_handle, .server = server } };
}

// ============================================================================
// SEND - Send HTTP response and close connection
// ============================================================================

~pub event send { conn: *ConnHandle, status: u16, body: []const u8, content_type: ?[]const u8 }
| sent {}
| failed { msg: []const u8 }

~proc send {
    const allocator = conn.allocator;
    const ct = if (content_type) |ct_str| ct_str else "text/plain";

    // Build HTTP response
    var response_buf: std.ArrayList(u8) = .empty;
    defer response_buf.deinit(allocator);

    var len_buf: [20]u8 = undefined;
    const len_str = std.fmt.bufPrint(&len_buf, "{}", .{body.len}) catch "0";
    if (headerPrefixClose(status)) |prefix| {
        response_buf.appendSlice(allocator, prefix) catch {};
        response_buf.appendSlice(allocator, len_str) catch {};
        response_buf.appendSlice(allocator, "\r\nContent-Type: ") catch {};
        response_buf.appendSlice(allocator, ct) catch {};
        response_buf.appendSlice(allocator, "\r\nConnection: close\r\n\r\n") catch {};
    } else {
        response_buf.appendSlice(allocator, "HTTP/1.1 ") catch {};
        var status_buf: [3]u8 = undefined;
        _ = std.fmt.bufPrint(&status_buf, "{}", .{status}) catch {};
        response_buf.appendSlice(allocator, &status_buf) catch {};
        response_buf.appendSlice(allocator, " ") catch {};
        response_buf.appendSlice(allocator, statusText(status)) catch {};
        response_buf.appendSlice(allocator, "\r\n") catch {};
        response_buf.appendSlice(allocator, "Content-Type: ") catch {};
        response_buf.appendSlice(allocator, ct) catch {};
        response_buf.appendSlice(allocator, "\r\n") catch {};
        response_buf.appendSlice(allocator, "Content-Length: ") catch {};
        response_buf.appendSlice(allocator, len_str) catch {};
        response_buf.appendSlice(allocator, "\r\nConnection: close\r\n\r\n") catch {};
    }

    // Body
    response_buf.appendSlice(allocator, body) catch {};

    // Send
    _ = conn.stream.writeAll(response_buf.items) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Write failed" } };
    };

    conn.stream.close();
    return .{ .sent = .{} };
}

// ============================================================================
// HANDLER - Abstract event for request handling
// ============================================================================
// Users implement this to handle requests. Default returns 404.

~[abstract]pub event handler { req: *Request }
| response { status: u16, body: []const u8, content_type: ?[]const u8 }

// Default implementation - 404 for everything
~handler = response { status: 404, body: "Not Found", content_type: null }

// ============================================================================
// SERVE - Main server flow (calls handler for each request)
// ============================================================================

~pub event serve { port: u16 }
| shutdown { reason: []const u8 }
| failed { msg: []const u8 }

// Brutal async server loop (kqueue + keep-alive) with direct handler dispatch.
// Keeps the DX: users implement ~orisha:handler.
const MAX_EVENTS = 64;
const MAX_CONNECTIONS = 1024;
const NUM_WORKERS = 4;
const CONNS_PER_WORKER = MAX_CONNECTIONS / NUM_WORKERS;

const Kevent = c.Kevent;

const AsyncConn = struct {
    fd: posix.fd_t,
    state: enum { reading, writing },
};

const WorkerContext = struct {
    id: usize,
    kq: posix.fd_t,
    connections: [CONNS_PER_WORKER]?AsyncConn,
    running: *std.atomic.Value(bool),
};

fn statusText(status: u16) []const u8 {
    return switch (status) {
        200 => "OK",
        201 => "Created",
        204 => "No Content",
        400 => "Bad Request",
        401 => "Unauthorized",
        403 => "Forbidden",
        404 => "Not Found",
        500 => "Internal Server Error",
        else => "Unknown",
    };
}

fn headerPrefixClose(status: u16) ?[]const u8 {
    return switch (status) {
        200 => "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: ",
        201 => "HTTP/1.1 201 Created\r\nContent-Type: text/plain\r\nContent-Length: ",
        204 => "HTTP/1.1 204 No Content\r\nContent-Type: text/plain\r\nContent-Length: ",
        400 => "HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\nContent-Length: ",
        401 => "HTTP/1.1 401 Unauthorized\r\nContent-Type: text/plain\r\nContent-Length: ",
        403 => "HTTP/1.1 403 Forbidden\r\nContent-Type: text/plain\r\nContent-Length: ",
        404 => "HTTP/1.1 404 Not Found\r\nContent-Type: text/plain\r\nContent-Length: ",
        500 => "HTTP/1.1 500 Internal Server Error\r\nContent-Type: text/plain\r\nContent-Length: ",
        else => null,
    };
}

fn headerPrefixKeepAlive(status: u16) ?[]const u8 {
    return switch (status) {
        200 => "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: ",
        201 => "HTTP/1.1 201 Created\r\nContent-Type: text/plain\r\nContent-Length: ",
        204 => "HTTP/1.1 204 No Content\r\nContent-Type: text/plain\r\nContent-Length: ",
        400 => "HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\nContent-Length: ",
        401 => "HTTP/1.1 401 Unauthorized\r\nContent-Type: text/plain\r\nContent-Length: ",
        403 => "HTTP/1.1 403 Forbidden\r\nContent-Type: text/plain\r\nContent-Length: ",
        404 => "HTTP/1.1 404 Not Found\r\nContent-Type: text/plain\r\nContent-Length: ",
        500 => "HTTP/1.1 500 Internal Server Error\r\nContent-Type: text/plain\r\nContent-Length: ",
        else => null,
    };
}

fn writeAll(fd: posix.fd_t, data: []const u8) bool {
    var offset: usize = 0;
    while (offset < data.len) {
        const n = posix.write(fd, data[offset..]) catch return false;
        if (n == 0) return false;
        offset += @intCast(n);
    }
    return true;
}

fn workerLoop(ctx: *WorkerContext) void {
    var events: [MAX_EVENTS]Kevent = undefined;
    var no_changes: [0]Kevent = undefined;

    while (ctx.running.load(.acquire)) {
        var timeout = std.posix.timespec{ .sec = 0, .nsec = 100_000_000 };
        const n = c.kevent(ctx.kq, &no_changes, 0, &events, MAX_EVENTS, &timeout);
        if (n <= 0) continue;

        for (events[0..@intCast(n)]) |event| {
            const fd: posix.fd_t = @intCast(event.ident);
            const slot: usize = @intCast(@mod(fd, CONNS_PER_WORKER));
            if (ctx.connections[slot]) |*conn| {
                if (conn.state == .reading) {
                    var buffer: [4096]u8 = undefined;
                    const bytes_read = posix.read(fd, &buffer) catch 0;
                    if (bytes_read == 0) {
                        posix.close(fd);
                        ctx.connections[slot] = null;
                        continue;
                    }

                    const request = buffer[0..bytes_read];
                    var method: []const u8 = "GET";
                    var path: []const u8 = "/";

                    var i: usize = 0;
                    while (i < request.len and request[i] != ' ') : (i += 1) {}
                    if (i < request.len) {
                        method = request[0..i];
                        i += 1;
                        var j: usize = i;
                        while (j < request.len and request[j] != ' ') : (j += 1) {}
                        if (j > i) {
                            path = request[i..j];
                        }
                    }

                    var req = Request{
                        .method = method,
                        .path = path,
                        .body = null,
                        .allocator = std.heap.page_allocator,
                    };

                    const result = @This().handler_event.handler(.{ .req = &req });
                    const res = switch (result) {
                        .response => |r| r,
                    };
                    const res_ct = if (res.content_type) |ct_str| ct_str else "text/plain";

                    conn.state = .writing;

                    if (std.mem.startsWith(u8, res.body, "HTTP/1.")) {
                        if (!writeAll(fd, res.body)) {
                            posix.close(fd);
                            ctx.connections[slot] = null;
                            continue;
                        }
                    } else {
                        var header_buf: [256]u8 = undefined;
                        const header = if (headerPrefixKeepAlive(res.status)) |prefix|
                            std.fmt.bufPrint(&header_buf, "{s}{d}\r\nContent-Type: {s}\r\nConnection: keep-alive\r\n\r\n", .{ prefix, res.body.len, res_ct }) catch
                                "HTTP/1.1 500 Internal Server Error\r\nContent-Length: 0\r\nConnection: close\r\n\r\n"
                        else
                            std.fmt.bufPrint(
                                &header_buf,
                                "HTTP/1.1 {d} {s}\r\nContent-Type: {s}\r\nContent-Length: {d}\r\nConnection: keep-alive\r\n\r\n",
                                .{ res.status, statusText(res.status), res_ct, res.body.len },
                            ) catch "HTTP/1.1 500 Internal Server Error\r\nContent-Length: 0\r\nConnection: close\r\n\r\n";

                        if (!writeAll(fd, header) or !writeAll(fd, res.body)) {
                            posix.close(fd);
                            ctx.connections[slot] = null;
                            continue;
                        }
                    }

                    conn.state = .reading;
                    var keep_alive_event: [1]Kevent = .{.{
                        .ident = @intCast(fd),
                        .filter = c.EVFILT.READ,
                        .flags = c.EV.ADD | c.EV.ONESHOT,
                        .fflags = 0,
                        .data = 0,
                        .udata = undefined,
                    }};
                    var keep_alive_empty: [0]Kevent = undefined;
                    _ = c.kevent(ctx.kq, &keep_alive_event, 1, &keep_alive_empty, 0, null);
                }
            }
        }
    }
}

~proc serve {
    const address = std.net.Address.parseIp("0.0.0.0", port) catch {
        return .{ .failed = .{ .msg = "Invalid address" } };
    };

    var server = address.listen(.{
        .reuse_address = true,
        .kernel_backlog = 512,
    }) catch {
        return .{ .failed = .{ .msg = "Failed to listen" } };
    };

    const O_NONBLOCK: u32 = 0x0004;
    const listen_fd = server.stream.handle;
    const flags = posix.fcntl(listen_fd, posix.F.GETFL, 0) catch 0;
    _ = posix.fcntl(listen_fd, posix.F.SETFL, flags | O_NONBLOCK) catch {};

    var running = std.atomic.Value(bool).init(true);
    var workers: [NUM_WORKERS]WorkerContext = undefined;
    var worker_threads: [NUM_WORKERS]std.Thread = undefined;

    for (0..NUM_WORKERS) |i| {
        const worker_kq = posix.kqueue() catch {
            return .{ .failed = .{ .msg = "Failed to create worker kqueue" } };
        };

        workers[i] = WorkerContext{
            .id = i,
            .kq = worker_kq,
            .connections = .{null} ** CONNS_PER_WORKER,
            .running = &running,
        };

        worker_threads[i] = std.Thread.spawn(.{}, workerLoop, .{&workers[i]}) catch {
            return .{ .failed = .{ .msg = "Failed to spawn worker thread" } };
        };
    }

    var next_worker: usize = 0;

    std.debug.print("Orisha listening on http://0.0.0.0:{}\n", .{port});
    std.debug.print("Running with {} workers + kqueue + TCP_NODELAY + keep-alive\n", .{NUM_WORKERS});

    while (true) {
        const conn = server.accept() catch continue;
        const client_fd = conn.stream.handle;

        const enable: i32 = 1;
        posix.setsockopt(client_fd, posix.IPPROTO.TCP, posix.TCP.NODELAY, std.mem.asBytes(&enable)) catch {};

        const client_flags = posix.fcntl(client_fd, posix.F.GETFL, 0) catch 0;
        _ = posix.fcntl(client_fd, posix.F.SETFL, client_flags | O_NONBLOCK) catch continue;

        const worker_id = next_worker;
        next_worker = (next_worker + 1) % NUM_WORKERS;
        const worker = &workers[worker_id];

        const slot: usize = @intCast(@mod(client_fd, CONNS_PER_WORKER));
        worker.connections[slot] = .{ .fd = client_fd, .state = .reading };

        var add_event: [1]Kevent = .{.{
            .ident = @intCast(client_fd),
            .filter = c.EVFILT.READ,
            .flags = c.EV.ADD | c.EV.ONESHOT,
            .fflags = 0,
            .data = 0,
            .udata = undefined,
        }};
        var no_events: [0]Kevent = undefined;
        _ = c.kevent(worker.kq, &add_event, 1, &no_events, 0, null);
    }

    return .{ .shutdown = .{ .reason = "Server stopped" } };
}

// ============================================================================
// ROUTER - Pattern-branch router transform
// ============================================================================
// Transforms pattern branches into dispatch logic
//
// Usage:
//   ~orisha:handler = orisha:router(req)
//   | [GET /] _ |> response { status: 200, body: "Hello", content_type: "text/plain" }
//   | [GET /users/:id] p |> response { status: 200, body: p.id, content_type: "text/plain" }
//   | [*] _ |> response { status: 404, body: "Not Found", content_type: "text/plain" }

~[comptime|transform]pub event router {
    invocation: *const Invocation,
    item: *const Item,
    program: *const Program,
    allocator: std.mem.Allocator
}
| transformed { program: *const Program }

~proc router {
    const ast_mod = @import("ast");
    const ast_functional = @import("ast_functional");
    const continuation_codegen = @import("continuation_codegen");

    // Get the flow containing this router invocation
    const flow = if (item.* == .flow)
        &item.flow
    else
        return .{ .transformed = .{ .program = program } };

    // Check if already transformed
    for (flow.invocation.annotations) |ann| {
        if (std.mem.startsWith(u8, ann, "@pass_ran")) {
            return .{ .transformed = .{ .program = program } };
        }
    }

    // Get the request expression from invocation args (the call-site value to splice)
    var req_expr: []const u8 = "req";
    for (invocation.args) |arg| {
        if (std.mem.eql(u8, arg.name, "req")) {
            req_expr = arg.value;
            break;
        }
    }

    // Collect pattern branches from continuations
    const PatternCont = struct {
        pattern: []const u8,
        cont: *const ast_mod.Continuation,
    };

    var patterns: std.ArrayList([]const u8) = .empty;
    var pattern_conts: std.ArrayList(PatternCont) = .empty;
    for (flow.continuations, 0..) |*cont, i| {
        if (cont.branch.len > 0 and cont.branch[0] == '[') {
            patterns.append(allocator, cont.branch) catch unreachable;
            pattern_conts.append(allocator, .{
                .pattern = cont.branch,
                .cont = &flow.continuations[i],
            }) catch unreachable;
        }
    }

    if (patterns.items.len == 0) {
        return .{ .transformed = .{ .program = program } };
    }

    std.debug.print("[ROUTER TRANSFORM] Found {} pattern branches\n", .{patterns.items.len});

    // Parsed pattern info
    const ParsedPattern = struct {
        raw: []const u8,
        method: []const u8,
        path: []const u8,
        params: []const []const u8,
        is_catchall: bool,
    };

    // Parse all patterns
    var parsed_patterns: std.ArrayList(ParsedPattern) = .empty;
    for (patterns.items) |pattern| {
        if (std.mem.eql(u8, pattern, "[*]")) {
            parsed_patterns.append(allocator, .{
                .raw = pattern,
                .method = "*",
                .path = "*",
                .params = &.{},
                .is_catchall = true,
            }) catch unreachable;
            continue;
        }

        const inner = pattern[1 .. pattern.len - 1];
        const space_idx = std.mem.indexOf(u8, inner, " ") orelse continue;
        const method = inner[0..space_idx];
        const path = inner[space_idx + 1 ..];

        var params_list: std.ArrayList([]const u8) = .empty;
        var path_iter = std.mem.splitScalar(u8, path, '/');
        while (path_iter.next()) |segment| {
            if (segment.len > 1 and segment[0] == ':') {
                params_list.append(allocator, segment[1..]) catch unreachable;
            }
        }

        parsed_patterns.append(allocator, .{
            .raw = pattern,
            .method = method,
            .path = path,
            .params = params_list.toOwnedSlice(allocator) catch unreachable,
            .is_catchall = false,
        }) catch unreachable;
    }

    // Build inline_body: direct control flow with branch bodies inlined.
    // This runs inline (in scope), so runtime values like the expr are accessible.
    var ib: std.ArrayList(u8) = .empty;
    ib.appendSlice(allocator, "//@koru:inline_stmt\n") catch unreachable;

    // Dispatch logic (group by method to reduce repeated checks)
    var catch_all: ?*const ParsedPattern = null;
    var catch_all_cont: ?*const ast_mod.Continuation = null;

    var methods: std.ArrayList([]const u8) = .empty;
    for (parsed_patterns.items) |*pp| {
        if (pp.is_catchall) {
            catch_all = pp;
            for (pattern_conts.items) |pc| {
                if (std.mem.eql(u8, pc.pattern, pp.raw)) {
                    catch_all_cont = pc.cont;
                    break;
                }
            }
            continue;
        }
        var seen = false;
        for (methods.items) |m| {
            if (std.mem.eql(u8, m, pp.method)) {
                seen = true;
                break;
            }
        }
        if (!seen) {
            methods.append(allocator, pp.method) catch unreachable;
        }
    }

    var result_counter: usize = 0;

    for (methods.items) |method_name| {
        ib.appendSlice(allocator, "    if (std.mem.eql(u8, (") catch unreachable;
        ib.appendSlice(allocator, req_expr) catch unreachable;
        ib.appendSlice(allocator, ").method, \"") catch unreachable;
        ib.appendSlice(allocator, method_name) catch unreachable;
        ib.appendSlice(allocator, "\")) {\n") catch unreachable;

        for (parsed_patterns.items) |*pp| {
            if (pp.is_catchall) continue;
            if (!std.mem.eql(u8, pp.method, method_name)) continue;

            if (pp.params.len == 0) {
                ib.appendSlice(allocator, "        if (std.mem.eql(u8, (") catch unreachable;
                ib.appendSlice(allocator, req_expr) catch unreachable;
                ib.appendSlice(allocator, ").path, \"") catch unreachable;
                ib.appendSlice(allocator, pp.path) catch unreachable;
                ib.appendSlice(allocator, "\")) {\n") catch unreachable;
                if (find_cont: {
                    for (pattern_conts.items) |pc| {
                        if (std.mem.eql(u8, pc.pattern, pp.raw)) break :find_cont pc.cont;
                    }
                    break :find_cont null;
                }) |cont| {
                    const code = continuation_codegen.generateContinuationChain(
                        allocator,
                        cont,
                        program.main_module_name,
                        &result_counter,
                        3,
                    ) catch unreachable;
                    ib.appendSlice(allocator, code) catch unreachable;
                }
                ib.appendSlice(allocator, "        }\n") catch unreachable;
            } else {
                var prefix_end: usize = 0;
                var path_iter = std.mem.splitScalar(u8, pp.path, '/');
                while (path_iter.next()) |seg| {
                    if (seg.len > 0 and seg[0] == ':') break;
                    prefix_end += seg.len + 1;
                }

                const prefix = if (prefix_end > 0) pp.path[0..prefix_end] else "/";

                ib.appendSlice(allocator, "        if (std.mem.startsWith(u8, (") catch unreachable;
                ib.appendSlice(allocator, req_expr) catch unreachable;
                ib.appendSlice(allocator, ").path, \"") catch unreachable;
                ib.appendSlice(allocator, prefix) catch unreachable;
                ib.appendSlice(allocator, "\")) {\n") catch unreachable;

                var len_buf: [10]u8 = undefined;
                const prefix_len_str = std.fmt.bufPrint(&len_buf, "{}", .{prefix.len}) catch "0";
                ib.appendSlice(allocator, "            const _p = (") catch unreachable;
                ib.appendSlice(allocator, req_expr) catch unreachable;
                ib.appendSlice(allocator, ").path;\n") catch unreachable;
                ib.appendSlice(allocator, "            const _param = if (_p.len >= ") catch unreachable;
                ib.appendSlice(allocator, prefix_len_str) catch unreachable;
                ib.appendSlice(allocator, ") _p[") catch unreachable;
                ib.appendSlice(allocator, prefix_len_str) catch unreachable;
                ib.appendSlice(allocator, "..] else \"\";\n") catch unreachable;
                if (find_cont: {
                    for (pattern_conts.items) |pc| {
                        if (std.mem.eql(u8, pc.pattern, pp.raw)) break :find_cont pc.cont;
                    }
                    break :find_cont null;
                }) |cont| {
                    if (cont.binding) |binding| {
                        if (!(binding.len > 0 and binding[0] == '_')) {
                            ib.appendSlice(allocator, "            const ") catch unreachable;
                            ib.appendSlice(allocator, binding) catch unreachable;
                            ib.appendSlice(allocator, " = .{ .") catch unreachable;
                            ib.appendSlice(allocator, pp.params[0]) catch unreachable;
                            ib.appendSlice(allocator, " = _param };\n") catch unreachable;
                        }
                    }
                    const code = continuation_codegen.generateContinuationChain(
                        allocator,
                        cont,
                        program.main_module_name,
                        &result_counter,
                        3,
                    ) catch unreachable;
                    ib.appendSlice(allocator, code) catch unreachable;
                }
                ib.appendSlice(allocator, "        }\n") catch unreachable;
            }
        }

        ib.appendSlice(allocator, "    }\n") catch unreachable;
    }

    const fallback = if (catch_all) |ca| ca.raw else parsed_patterns.items[0].raw;
    const fallback_cont = catch_all_cont orelse blk: {
        for (pattern_conts.items) |pc| {
            if (std.mem.eql(u8, pc.pattern, fallback)) break :blk pc.cont;
        }
        break :blk null;
    };

    if (fallback_cont) |cont| {
        const code = continuation_codegen.generateContinuationChain(
            allocator,
            cont,
            program.main_module_name,
            &result_counter,
            1,
        ) catch unreachable;
        ib.appendSlice(allocator, code) catch unreachable;
    }

    const inline_body_str = ib.toOwnedSlice(allocator) catch unreachable;
    std.debug.print("[ROUTER TRANSFORM] Generated inline dispatch:\n{s}\n", .{inline_body_str});

    // Mark as transformed (keep original invocation path)
    const new_inv_annotations = allocator.alloc([]const u8, flow.invocation.annotations.len + 1) catch unreachable;
    for (flow.invocation.annotations, 0..) |ann, j| {
        new_inv_annotations[j] = ann;
    }
    new_inv_annotations[flow.invocation.annotations.len] = allocator.dupe(u8, "@pass_ran(\"transform\")") catch unreachable;

    const new_invocation = ast_mod.Invocation{
        .path = flow.invocation.path,
        .args = flow.invocation.args,
        .annotations = new_inv_annotations,
    };

    const empty_conts = allocator.alloc(ast_mod.Continuation, 0) catch unreachable;

    const transformed_flow = ast_mod.Flow{
        .invocation = new_invocation,
        .continuations = empty_conts,
        .annotations = flow.annotations,
        .pre_label = flow.pre_label,
        .post_label = flow.post_label,
        .super_shape = flow.super_shape,
        .inline_body = inline_body_str,
        .preamble_code = flow.preamble_code,
        .is_pure = flow.is_pure,
        .is_transitively_pure = flow.is_transitively_pure,
        .impl_of = flow.impl_of,
        .is_impl = flow.is_impl,
        .module = flow.module,
        .location = flow.location,
    };

    const new_item = ast_mod.Item{ .flow = transformed_flow };

    // Replace using recursive search (handles .flow and nested module_decls)
    const maybe_new_program = ast_functional.replaceFlowRecursive(allocator, program, flow, new_item) catch unreachable;
    if (maybe_new_program) |new_program_val| {
        const result = allocator.create(ast_mod.Program) catch unreachable;
        result.* = new_program_val;
        return .{ .transformed = .{ .program = result } };
    } else {
        std.debug.print("ERROR: Router transform failed - flow not found in program\n", .{});
        return .{ .transformed = .{ .program = program } };
    }
}
