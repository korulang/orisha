// Orisha - High-performance web framework for Koru
//
// Public API:
//   ~orisha:serve(port)     - Start server (calls abstract handler for each request)
//   ~orisha:handler         - Abstract event users implement for request handling
//   ~orisha:router(req)     - Pattern-branch router transform
//
// Example:
//   ~import "$orisha"
//
//   // Implement the handler with routing
//   ~orisha:handler = orisha:router(req)
//   | [GET /] _ |> response { status: 200, body: "Hello World" }
//   | [GET /users/:id] p |> response { status: 200, body: p.id }
//   | [*] _ |> response { status: 404, body: "Not Found" }
//
//   // Start the server
//   ~orisha:serve(port: 3000)
//   | shutdown s |> io.println(message: s.reason)
//   | failed f |> io.println(message: f.msg)

~import "$std/compiler"
~import "$std/io"

~std.compiler:requires {
    exe.linkLibC();
}

const std = @import("std");
const ast = @import("ast");
const Program = ast.Program;
const posix = std.posix;

// ============================================================================
// PUBLIC TYPES
// ============================================================================

pub const Request = struct {
    method: []const u8,
    path: []const u8,
    body: ?[]const u8,

    // For param extraction by router
    allocator: std.mem.Allocator,
};

pub const ServerHandle = struct {
    inner: std.net.Server,
    allocator: std.mem.Allocator,
};

pub const ConnHandle = struct {
    stream: std.net.Stream,
    allocator: std.mem.Allocator,
};

// ============================================================================
// LISTEN - Start listening on a port
// ============================================================================

~pub event listen { port: u16 }
| listening { server: *ServerHandle }
| failed { msg: []const u8 }

~proc listen {
    const allocator = std.heap.c_allocator;

    const address = std.net.Address.parseIp("0.0.0.0", port) catch {
        return .{ .failed = .{ .msg = "Invalid address" } };
    };

    const server = address.listen(.{
        .reuse_address = true,
        .kernel_backlog = 128,
    }) catch {
        return .{ .failed = .{ .msg = "Failed to listen" } };
    };

    const handle = allocator.create(ServerHandle) catch {
        return .{ .failed = .{ .msg = "Failed to allocate server handle" } };
    };
    handle.* = .{ .inner = server, .allocator = allocator };

    std.debug.print("Orisha listening on http://0.0.0.0:{}\n", .{port});
    return .{ .listening = .{ .server = handle } };
}

// ============================================================================
// ACCEPT - Accept connection and parse HTTP request
// ============================================================================

~pub event accept { server: *ServerHandle }
| request { req: *Request, conn: *ConnHandle, server: *ServerHandle }
| failed { msg: []const u8, server: *ServerHandle }

~proc accept {
    const allocator = server.allocator;

    // Accept connection
    const conn = server.inner.accept() catch {
        return .{ .failed = .{ .msg = "Accept failed", .server = server } };
    };

    // Read HTTP request
    var buffer: [4096]u8 = undefined;
    const bytes_read = conn.stream.read(&buffer) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Read failed", .server = server } };
    };

    if (bytes_read == 0) {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Empty request", .server = server } };
    }

    // Parse HTTP request line: "GET /path HTTP/1.1"
    const request_data = buffer[0..bytes_read];
    var method: []const u8 = "GET";
    var path: []const u8 = "/";

    if (std.mem.indexOf(u8, request_data, " ")) |method_end| {
        method = request_data[0..method_end];
        const after_method = request_data[method_end + 1..];
        if (std.mem.indexOf(u8, after_method, " ")) |path_end| {
            path = after_method[0..path_end];
        }
    }

    // Allocate request
    const req = allocator.create(Request) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Failed to allocate request", .server = server } };
    };
    req.* = .{
        .method = allocator.dupe(u8, method) catch method,
        .path = allocator.dupe(u8, path) catch path,
        .body = null,
        .allocator = allocator,
    };

    // Allocate connection handle
    const conn_handle = allocator.create(ConnHandle) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Failed to allocate connection", .server = server } };
    };
    conn_handle.* = .{ .stream = conn.stream, .allocator = allocator };

    return .{ .request = .{ .req = req, .conn = conn_handle, .server = server } };
}

// ============================================================================
// SEND - Send HTTP response and close connection
// ============================================================================

~pub event send { conn: *ConnHandle, status: u16, body: []const u8 }
| sent {}
| failed { msg: []const u8 }

~proc send {
    const allocator = conn.allocator;

    // Build HTTP response
    var response_buf: std.ArrayList(u8) = .empty;
    defer response_buf.deinit(allocator);

    // Status line
    const status_text = switch (status) {
        200 => "OK",
        201 => "Created",
        204 => "No Content",
        400 => "Bad Request",
        401 => "Unauthorized",
        403 => "Forbidden",
        404 => "Not Found",
        500 => "Internal Server Error",
        else => "Unknown",
    };

    response_buf.appendSlice(allocator, "HTTP/1.1 ") catch {};
    var status_buf: [3]u8 = undefined;
    _ = std.fmt.bufPrint(&status_buf, "{}", .{status}) catch {};
    response_buf.appendSlice(allocator, &status_buf) catch {};
    response_buf.appendSlice(allocator, " ") catch {};
    response_buf.appendSlice(allocator, status_text) catch {};
    response_buf.appendSlice(allocator, "\r\n") catch {};

    // Headers
    response_buf.appendSlice(allocator, "Content-Type: text/plain\r\n") catch {};
    response_buf.appendSlice(allocator, "Content-Length: ") catch {};
    var len_buf: [20]u8 = undefined;
    const len_str = std.fmt.bufPrint(&len_buf, "{}", .{body.len}) catch "0";
    response_buf.appendSlice(allocator, len_str) catch {};
    response_buf.appendSlice(allocator, "\r\nConnection: close\r\n\r\n") catch {};

    // Body
    response_buf.appendSlice(allocator, body) catch {};

    // Send
    _ = conn.stream.writeAll(response_buf.items) catch {
        conn.stream.close();
        return .{ .failed = .{ .msg = "Write failed" } };
    };

    conn.stream.close();
    return .{ .sent = .{} };
}

// ============================================================================
// HANDLER - Abstract event for request handling
// ============================================================================
// Users implement this to handle requests. Default returns 404.

~[abstract]pub event handler { req: *Request }
| response { status: u16, body: []const u8 }

// Default implementation - 404 for everything
~handler = response { status: 404, body: "Not Found" }

// ============================================================================
// SERVE - Main server flow (calls handler for each request)
// ============================================================================

~pub event serve { port: u16 }
| shutdown { reason: []const u8 }
| failed { msg: []const u8 }

// serve delegates to listen, then loops forever accepting requests.
// Currently only returns 'failed' if listen fails.
// 'shutdown' will be returned when graceful shutdown is implemented.
~serve = listen(port)
| listening l |> #accept_loop accept(server: l.server)
    | request r |> handler(req: r.req)
        | response res |> send(conn: r.conn, status: res.status, body: res.body)
            | sent |> @accept_loop(server: r.server)
            | failed _ |> @accept_loop(server: r.server)
    | failed f |> @accept_loop(server: f.server)
| failed f |> failed { msg: f.msg }

// ============================================================================
// ROUTER - Pattern-branch router transform
// ============================================================================
// Transforms pattern branches into dispatch logic
//
// Usage:
//   ~orisha:handler = orisha:router(req)
//   | [GET /] _ |> response { status: 200, body: "Hello" }
//   | [GET /users/:id] p |> response { status: 200, body: p.id }
//   | [*] _ |> response { status: 404, body: "Not Found" }

~[comptime|transform]pub event router {
    invocation: *const Invocation,
    item: *const Item,
    program: *const Program,
    allocator: std.mem.Allocator
}
| transformed { program: *const Program }

~proc router {
    const ast_mod = @import("ast");
    const ast_functional = @import("ast_functional");

    // Get the flow containing this router invocation
    const flow = if (item.* == .flow)
        &item.flow
    else
        return .{ .transformed = .{ .program = program } };

    // Check if already transformed
    for (flow.invocation.annotations) |ann| {
        if (std.mem.startsWith(u8, ann, "@pass_ran")) {
            return .{ .transformed = .{ .program = program } };
        }
    }

    // Get the request expression from invocation args (the call-site value to splice)
    var req_expr: []const u8 = "req";
    for (invocation.args) |arg| {
        if (std.mem.eql(u8, arg.name, "req")) {
            req_expr = arg.value;
            break;
        }
    }

    // Collect pattern branches from continuations
    var patterns: std.ArrayList([]const u8) = .empty;
    for (flow.continuations) |cont| {
        if (cont.branch.len > 0 and cont.branch[0] == '[') {
            patterns.append(allocator, cont.branch) catch unreachable;
        }
    }

    if (patterns.items.len == 0) {
        return .{ .transformed = .{ .program = program } };
    }

    std.debug.print("[ROUTER TRANSFORM] Found {} pattern branches\n", .{patterns.items.len});

    // Parsed pattern info
    const ParsedPattern = struct {
        raw: []const u8,
        method: []const u8,
        path: []const u8,
        params: []const []const u8,
        is_catchall: bool,
    };

    // Parse all patterns
    var parsed_patterns: std.ArrayList(ParsedPattern) = .empty;
    for (patterns.items) |pattern| {
        if (std.mem.eql(u8, pattern, "[*]")) {
            parsed_patterns.append(allocator, .{
                .raw = pattern,
                .method = "*",
                .path = "*",
                .params = &.{},
                .is_catchall = true,
            }) catch unreachable;
            continue;
        }

        const inner = pattern[1 .. pattern.len - 1];
        const space_idx = std.mem.indexOf(u8, inner, " ") orelse continue;
        const method = inner[0..space_idx];
        const path = inner[space_idx + 1 ..];

        var params_list: std.ArrayList([]const u8) = .empty;
        var path_iter = std.mem.splitScalar(u8, path, '/');
        while (path_iter.next()) |segment| {
            if (segment.len > 1 and segment[0] == ':') {
                params_list.append(allocator, segment[1..]) catch unreachable;
            }
        }

        parsed_patterns.append(allocator, .{
            .raw = pattern,
            .method = method,
            .path = path,
            .params = params_list.toOwnedSlice(allocator) catch unreachable,
            .is_catchall = false,
        }) catch unreachable;
    }

    // Build inline_body: a Zig block expression that dispatches on the route
    // This runs inline (in scope), so runtime values like the expr are accessible.
    var ib: std.ArrayList(u8) = .empty;
    ib.appendSlice(allocator, "blk: {\n") catch unreachable;

    // Define the route result union type inline
    ib.appendSlice(allocator, "    const RouteResult = union(enum) {\n") catch unreachable;
    for (parsed_patterns.items) |pp| {
        ib.appendSlice(allocator, "        @\"") catch unreachable;
        ib.appendSlice(allocator, pp.raw) catch unreachable;
        ib.appendSlice(allocator, "\": struct {") catch unreachable;
        for (pp.params) |param_name| {
            ib.appendSlice(allocator, " ") catch unreachable;
            ib.appendSlice(allocator, param_name) catch unreachable;
            ib.appendSlice(allocator, ": []const u8,") catch unreachable;
        }
        ib.appendSlice(allocator, " },\n") catch unreachable;
    }
    ib.appendSlice(allocator, "    };\n") catch unreachable;

    // Dispatch logic
    var catch_all: ?*const ParsedPattern = null;

    for (parsed_patterns.items) |*pp| {
        if (pp.is_catchall) {
            catch_all = pp;
            continue;
        }

        ib.appendSlice(allocator, "    if (std.mem.eql(u8, (") catch unreachable;
        ib.appendSlice(allocator, req_expr) catch unreachable;
        ib.appendSlice(allocator, ").method, \"") catch unreachable;
        ib.appendSlice(allocator, pp.method) catch unreachable;
        ib.appendSlice(allocator, "\")") catch unreachable;

        if (pp.params.len == 0) {
            ib.appendSlice(allocator, " and std.mem.eql(u8, (") catch unreachable;
            ib.appendSlice(allocator, req_expr) catch unreachable;
            ib.appendSlice(allocator, ").path, \"") catch unreachable;
            ib.appendSlice(allocator, pp.path) catch unreachable;
            ib.appendSlice(allocator, "\")) {\n") catch unreachable;
            ib.appendSlice(allocator, "        break :blk RouteResult{ .@\"") catch unreachable;
            ib.appendSlice(allocator, pp.raw) catch unreachable;
            ib.appendSlice(allocator, "\" = .{} };\n    }\n") catch unreachable;
        } else {
            var prefix_end: usize = 0;
            var path_iter = std.mem.splitScalar(u8, pp.path, '/');
            while (path_iter.next()) |seg| {
                if (seg.len > 0 and seg[0] == ':') break;
                prefix_end += seg.len + 1;
            }

            const prefix = if (prefix_end > 0) pp.path[0..prefix_end] else "/";

            ib.appendSlice(allocator, " and std.mem.startsWith(u8, (") catch unreachable;
            ib.appendSlice(allocator, req_expr) catch unreachable;
            ib.appendSlice(allocator, ").path, \"") catch unreachable;
            ib.appendSlice(allocator, prefix) catch unreachable;
            ib.appendSlice(allocator, "\")) {\n") catch unreachable;

            var len_buf: [10]u8 = undefined;
            const prefix_len_str = std.fmt.bufPrint(&len_buf, "{}", .{prefix.len}) catch "0";
            ib.appendSlice(allocator, "        const _p = (") catch unreachable;
            ib.appendSlice(allocator, req_expr) catch unreachable;
            ib.appendSlice(allocator, ").path;\n") catch unreachable;
            ib.appendSlice(allocator, "        const _param = if (_p.len >= ") catch unreachable;
            ib.appendSlice(allocator, prefix_len_str) catch unreachable;
            ib.appendSlice(allocator, ") _p[") catch unreachable;
            ib.appendSlice(allocator, prefix_len_str) catch unreachable;
            ib.appendSlice(allocator, "..] else \"\";\n") catch unreachable;

            ib.appendSlice(allocator, "        break :blk RouteResult{ .@\"") catch unreachable;
            ib.appendSlice(allocator, pp.raw) catch unreachable;
            ib.appendSlice(allocator, "\" = .{ .") catch unreachable;
            ib.appendSlice(allocator, pp.params[0]) catch unreachable;
            ib.appendSlice(allocator, " = _param } };\n    }\n") catch unreachable;
        }
    }

    const fallback = if (catch_all) |ca| ca.raw else parsed_patterns.items[0].raw;
    ib.appendSlice(allocator, "    break :blk RouteResult{ .@\"") catch unreachable;
    ib.appendSlice(allocator, fallback) catch unreachable;
    ib.appendSlice(allocator, "\" = .{} };\n}") catch unreachable;

    const inline_body_str = ib.toOwnedSlice(allocator) catch unreachable;
    std.debug.print("[ROUTER TRANSFORM] Generated inline dispatch:\n{s}\n", .{inline_body_str});

    // Mark as transformed (keep original invocation path)
    const new_inv_annotations = allocator.alloc([]const u8, flow.invocation.annotations.len + 1) catch unreachable;
    for (flow.invocation.annotations, 0..) |ann, j| {
        new_inv_annotations[j] = ann;
    }
    new_inv_annotations[flow.invocation.annotations.len] = allocator.dupe(u8, "@pass_ran(\"transform\")") catch unreachable;

    const new_invocation = ast_mod.Invocation{
        .path = flow.invocation.path,
        .args = flow.invocation.args,
        .annotations = new_inv_annotations,
    };

    const transformed_flow = ast_mod.Flow{
        .invocation = new_invocation,
        .continuations = flow.continuations,
        .annotations = flow.annotations,
        .pre_label = flow.pre_label,
        .post_label = flow.post_label,
        .super_shape = flow.super_shape,
        .inline_body = inline_body_str,
        .preamble_code = flow.preamble_code,
        .is_pure = flow.is_pure,
        .is_transitively_pure = flow.is_transitively_pure,
        .impl_of = flow.impl_of,
        .is_impl = flow.is_impl,
        .module = flow.module,
        .location = flow.location,
    };

    const new_item = ast_mod.Item{ .flow = transformed_flow };

    // Replace using recursive search (handles .flow and nested module_decls)
    const maybe_new_program = ast_functional.replaceFlowRecursive(allocator, program, flow, new_item) catch unreachable;
    if (maybe_new_program) |new_program_val| {
        const result = allocator.create(ast_mod.Program) catch unreachable;
        result.* = new_program_val;
        return .{ .transformed = .{ .program = result } };
    } else {
        std.debug.print("ERROR: Router transform failed - flow not found in program\n", .{});
        return .{ .transformed = .{ .program = program } };
    }
}
