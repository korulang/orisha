// Orisha Static Server - With Compile-Time Embedded Content
//
// The index.html file is embedded INTO THE BINARY at compile time.
// Zero disk I/O at runtime. The bytes are just... there.

~import "$orisha/router"

const std = @import("std");

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

pub const Server = struct {
    inner: std.net.Server,
};

pub const Connection = struct {
    stream: std.net.Stream,
    address: std.net.Address,
};

// ============================================================================
// DECLARATIVE ROUTES
// ============================================================================

~[norun]pub event route { route: Expression, source: Source }

~route(GET /) {
    "file": "public/index.html"
}

~route(GET /about) {
    "file": "public/about.html"
}

~route(GET /api/health) {
    "content-type": "application/json",
    "body": "OK"
}

// ============================================================================
// ROUTE COLLECTOR (comptime)
// ============================================================================

// Invoke the collector from the module at compile time
~orisha.router:collect_routes()
| done |> _

// ============================================================================
// GENERATED ROUTES - AUTO-GENERATED AT COMPILE TIME
// ============================================================================

// The route collector walks the AST, reads files, computes etags,
// and generates this module with all content embedded
const routes = @import("generated/routes.zig");

// ============================================================================
// MAIN FLOW - ASYNC EVENT LOOP WITH KQUEUE
// ============================================================================

~listen_async(port: 3000)
| listening |> _
| failed |> _

// ============================================================================
// ASYNC EVENT LOOP WITH KQUEUE
// ============================================================================

const posix = std.posix;
const c = std.c;

const MAX_EVENTS = 64;
const MAX_CONNECTIONS = 1024;

// Use std.c.Kevent and constants
const Kevent = c.Kevent;

// Connection state for async handling
const AsyncConn = struct {
    fd: posix.fd_t,
    state: enum { reading, writing },
    response: ?[]const u8,
};

~event listen_async { port: u16 }
| listening {}
| failed { msg: []const u8 }

~proc listen_async {
    // Create listening socket
    const address = std.net.Address.parseIp("0.0.0.0", port) catch {
        return .{ .failed = .{ .msg = "Invalid address" } };
    };

    var server = address.listen(.{
        .reuse_address = true,
        .kernel_backlog = 512,
    }) catch {
        return .{ .failed = .{ .msg = "Failed to listen" } };
    };

    // Make listening socket non-blocking (O_NONBLOCK = 0x0004 on macOS)
    const O_NONBLOCK: u32 = 0x0004;
    const listen_fd = server.stream.handle;
    const flags = posix.fcntl(listen_fd, posix.F.GETFL, 0) catch 0;
    _ = posix.fcntl(listen_fd, posix.F.SETFL, flags | O_NONBLOCK) catch {};

    // Create kqueue
    const kq = posix.kqueue() catch {
        return .{ .failed = .{ .msg = "Failed to create kqueue" } };
    };

    // Register listening socket for read events (new connections)
    var changes: [1]Kevent = .{
        .{
            .ident = @intCast(listen_fd),
            .filter = c.EVFILT.READ,
            .flags = c.EV.ADD,
            .fflags = 0,
            .data = 0,
            .udata = undefined,
        },
    };
    var empty_events: [0]Kevent = undefined;
    _ = c.kevent(kq, &changes, 1, &empty_events, 0, null);

    std.debug.print("Orisha KEEPALIVE listening on http://0.0.0.0:{}\n", .{port});
    std.debug.print("Serving {} routes with kqueue + TCP_NODELAY + keep-alive\n", .{routes.routes.len});

    // Connection pool
    var connections: [MAX_CONNECTIONS]?AsyncConn = .{null} ** MAX_CONNECTIONS;

    // Event loop
    var events: [MAX_EVENTS]Kevent = undefined;
    var no_changes: [0]Kevent = undefined;
    while (true) {
        const n = c.kevent(kq, &no_changes, 0, &events, MAX_EVENTS, null);
        if (n <= 0) continue;

        for (events[0..@intCast(n)]) |event| {
            const fd: posix.fd_t = @intCast(event.ident);

            if (fd == listen_fd) {
                // New connection
                while (true) {
                    const conn = server.accept() catch break;
                    const client_fd = conn.stream.handle;

                    // TCP_NODELAY on client - critical for latency!
                    const enable: i32 = 1;
                    posix.setsockopt(client_fd, posix.IPPROTO.TCP, posix.TCP.NODELAY, std.mem.asBytes(&enable)) catch {};

                    // Make client socket non-blocking
                    const client_flags = posix.fcntl(client_fd, posix.F.GETFL, 0) catch 0;
                    _ = posix.fcntl(client_fd, posix.F.SETFL, client_flags | O_NONBLOCK) catch continue;

                    // Store connection
                    const slot: usize = @intCast(@mod(client_fd, MAX_CONNECTIONS));
                    connections[slot] = .{
                        .fd = client_fd,
                        .state = .reading,
                        .response = null,
                    };

                    // Register for read events
                    var add_event: [1]Kevent = .{
                        .{
                            .ident = @intCast(client_fd),
                            .filter = c.EVFILT.READ,
                            .flags = c.EV.ADD | c.EV.ONESHOT,
                            .fflags = 0,
                            .data = 0,
                            .udata = undefined,
                        },
                    };
                    var no_events: [0]Kevent = undefined;
                    _ = c.kevent(kq, &add_event, 1, &no_events, 0, null);
                }
            } else {
                // Client socket event
                const slot: usize = @intCast(@mod(fd, MAX_CONNECTIONS));
                if (connections[slot]) |*conn| {
                    if (conn.state == .reading) {
                        // Read request
                        var buffer: [4096]u8 = undefined;
                        const bytes_read = posix.read(fd, &buffer) catch 0;

                        if (bytes_read == 0) {
                            // Connection closed
                            posix.close(fd);
                            connections[slot] = null;
                            continue;
                        }

                        // Parse request (minimal: just get path)
                        const request = buffer[0..bytes_read];
                        var path: []const u8 = "/";

                        // Find path in "GET /path HTTP/1.1"
                        if (std.mem.indexOf(u8, request, " ")) |start| {
                            const after_method = request[start + 1..];
                            if (std.mem.indexOf(u8, after_method, " ")) |end| {
                                path = after_method[0..end];
                            }
                        }

                        // Lookup response blob
                        conn.response = routes.lookup("GET", path) orelse
                            "HTTP/1.1 404 Not Found\r\nContent-Length: 9\r\nConnection: close\r\n\r\nNot Found";
                        conn.state = .writing;

                        // Write response immediately (non-blocking)
                        _ = posix.write(fd, conn.response.?) catch {
                            posix.close(fd);
                            connections[slot] = null;
                            continue;
                        };

                        // Keep-alive: re-register for next request
                        conn.state = .reading;
                        conn.response = null;
                        var keep_alive_event: [1]Kevent = .{
                            .{
                                .ident = @intCast(fd),
                                .filter = c.EVFILT.READ,
                                .flags = c.EV.ADD | c.EV.ONESHOT,
                                .fflags = 0,
                                .data = 0,
                                .udata = undefined,
                            },
                        };
                        var keep_alive_empty: [0]Kevent = undefined;
                        _ = c.kevent(kq, &keep_alive_event, 1, &keep_alive_empty, 0, null);
                    }
                }
            }
        }
    }

    return .{ .listening = .{} };
}

~event accept { server: *Server }
| connection { conn: *Connection[open!], server: *Server }
| failed { server: *Server }

~proc accept {
    const allocator = std.heap.page_allocator;
    const conn = server.inner.accept() catch {
        return .{ .failed = .{ .server = server } };
    };

    const conn_ptr = allocator.create(Connection) catch {
        return .{ .failed = .{ .server = server } };
    };
    conn_ptr.* = .{ .stream = conn.stream, .address = conn.address };

    return .{ .connection = .{ .conn = conn_ptr, .server = server } };
}

~event read_request { conn: *Connection[open] }
| request { conn: *Connection[open], method: []const u8, path: []const u8 }
| closed {}

~proc read_request {
    var buffer: [4096]u8 = undefined;
    const n = conn.stream.read(&buffer) catch {
        return .{ .closed = .{} };
    };

    if (n == 0) {
        return .{ .closed = .{} };
    }

    const first_line_end = std.mem.indexOf(u8, buffer[0..n], "\r\n") orelse n;
    const request_line = buffer[0..first_line_end];

    var parts = std.mem.tokenizeScalar(u8, request_line, ' ');
    const method = parts.next() orelse "GET";
    const path = parts.next() orelse "/";

    return .{ .request = .{ .conn = conn, .method = method, .path = path } };
}

// Route to embedded content - all computed at compile time!
~event send_static { conn: *Connection[open], path: []const u8 }
| sent { conn: *Connection[open] }
| not_found { conn: *Connection[open] }

~proc send_static {
    // Lookup route - returns complete HTTP response blob (headers + body)
    if (routes.lookup("GET", path)) |response| {
        // ONE SYSCALL. ZERO FORMATTING. JUST DUMP THE BLOB.
        _ = conn.stream.writeAll(response) catch {
            return .{ .not_found = .{ .conn = conn } };
        };
        return .{ .sent = .{ .conn = conn } };
    }

    // 404 for anything else
    const not_found_response = "HTTP/1.1 404 Not Found\r\nContent-Length: 9\r\nConnection: close\r\n\r\nNot Found";
    _ = conn.stream.writeAll(not_found_response) catch {};
    return .{ .not_found = .{ .conn = conn } };
}

~event close { conn: *Connection[!open] }
| closed {}

~proc close {
    conn.stream.close();
    std.heap.page_allocator.destroy(conn);
    return .{ .closed = .{} };
}
