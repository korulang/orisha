// Router module - comptime route collection and manifest generation
//
// This module:
// 1. Walks the AST to find [norun] route declarations
// 2. Parses their Source block configs (JSON-like)
// 3. Reads file content for file routes
// 4. Computes SHA256 etags for cache validation
// 5. Generates src/generated/routes.zig with all processed routes

const std = @import("std");
const ast = @import("ast");
const Program = ast.Program;
const Sha256 = std.crypto.hash.sha2.Sha256;

// ============================================================================
// DATA STRUCTURES
// ============================================================================

const RouteConfig = struct {
    file: ?[]const u8 = null,
    body: ?[]const u8 = null,
    content_type: ?[]const u8 = null,
};

const ProcessedRoute = struct {
    method: []const u8,
    path: []const u8,
    content: []const u8,
    content_length: usize,
    etag: [64]u8,  // hex-encoded SHA256
    content_type: []const u8,
};

// ============================================================================
// COMPTIME EVENT
// ============================================================================

~[comptime] event collect_routes {
    program: *const Program,
    allocator: std.mem.Allocator
}
| done { route_count: usize }

~[comptime] proc collect_routes {
    std.debug.print("\n=== ORISHA ROUTE COLLECTOR ===\n", .{});
    std.debug.print("Walking AST ({} items)...\n\n", .{program.items.len});

    var routes = std.ArrayList(ProcessedRoute).init(allocator);
    defer routes.deinit();

    // Walk AST looking for route invocations
    for (program.items) |item| {
        if (item != .flow) continue;
        const inv = item.flow.invocation;

        // Check if this is a "route" event
        if (inv.path.segments.len == 0) continue;
        const last_segment = inv.path.segments[inv.path.segments.len - 1];
        if (!std.mem.eql(u8, last_segment, "route")) continue;

        // Parse route expression: "GET /" -> method + path
        const route_expr = if (inv.args.len > 0) inv.args[0].value else continue;
        const method, const path = parseRouteExpr(route_expr);

        std.debug.print("Processing: {s} {s}\n", .{method, path});

        // Find and parse Source block config
        const config = parseSourceConfig(inv, allocator);

        // Process based on config type
        if (config.file) |file_path| {
            std.debug.print("  Reading file: {s}\n", .{file_path});
            const content = std.fs.cwd().readFileAlloc(allocator, file_path, 10 * 1024 * 1024) catch |err| {
                std.debug.print("  ERROR reading file: {}\n", .{err});
                continue;
            };

            var etag_buf: [64]u8 = undefined;
            computeEtag(content, &etag_buf);

            routes.append(.{
                .method = method,
                .path = path,
                .content = content,
                .content_length = content.len,
                .etag = etag_buf,
                .content_type = config.content_type orelse mimeTypeFromPath(file_path),
            }) catch continue;

            std.debug.print("  Content-Length: {}\n", .{content.len});
            std.debug.print("  ETag: \"{s}\"\n", .{etag_buf[0..16]});

        } else if (config.body) |body| {
            std.debug.print("  Inline body: {} bytes\n", .{body.len});

            var etag_buf: [64]u8 = undefined;
            computeEtag(body, &etag_buf);

            routes.append(.{
                .method = method,
                .path = path,
                .content = body,
                .content_length = body.len,
                .etag = etag_buf,
                .content_type = config.content_type orelse "text/plain",
            }) catch continue;
        }
    }

    std.debug.print("\n=== Generating routes.zig ({} routes) ===\n", .{routes.items.len});

    // Generate the routes.zig file
    generateRoutesFile(allocator, routes.items) catch |err| {
        std.debug.print("ERROR generating routes.zig: {}\n", .{err});
        return .{ .done = .{ .route_count = 0 } };
    };

    std.debug.print("=== Done! ===\n\n", .{});
    return .{ .done = .{ .route_count = routes.items.len } };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

fn parseRouteExpr(expr: []const u8) struct { []const u8, []const u8 } {
    // Parse "GET /path" -> ("GET", "/path")
    var iter = std.mem.tokenizeScalar(u8, expr, ' ');
    const method = iter.next() orelse "GET";
    const path = iter.next() orelse "/";
    return .{ method, path };
}

fn parseSourceConfig(inv: *const ast.Invocation, allocator: std.mem.Allocator) RouteConfig {
    var config = RouteConfig{};

    for (inv.args) |arg| {
        if (arg.source_value) |source| {
            // Parse JSON-like config: "key": "value"
            var lines = std.mem.splitScalar(u8, source.text, '\n');
            while (lines.next()) |line| {
                const trimmed = std.mem.trim(u8, line, " \t\r");
                if (trimmed.len == 0) continue;

                // Find "key": "value" pattern
                if (std.mem.indexOf(u8, trimmed, "\"file\"")) |_| {
                    config.file = extractQuotedValue(trimmed, allocator);
                } else if (std.mem.indexOf(u8, trimmed, "\"body\"")) |_| {
                    config.body = extractQuotedValue(trimmed, allocator);
                } else if (std.mem.indexOf(u8, trimmed, "\"content-type\"")) |_| {
                    config.content_type = extractQuotedValue(trimmed, allocator);
                }
            }
        }
    }

    return config;
}

fn extractQuotedValue(line: []const u8, allocator: std.mem.Allocator) ?[]const u8 {
    // Find the value in: "key": "value" or "key": "value",
    // Look for the colon, then find the quoted value after it
    const colon_pos = std.mem.indexOf(u8, line, ":") orelse return null;
    const after_colon = line[colon_pos + 1..];

    // Find first quote after colon
    const first_quote = std.mem.indexOf(u8, after_colon, "\"") orelse return null;
    const value_start = after_colon[first_quote + 1..];

    // Find closing quote (handle escaped quotes later if needed)
    const end_quote = std.mem.indexOf(u8, value_start, "\"") orelse return null;

    // Duplicate the string so it persists
    return allocator.dupe(u8, value_start[0..end_quote]) catch null;
}

fn computeEtag(content: []const u8, out: *[64]u8) void {
    var hash: [32]u8 = undefined;
    Sha256.hash(content, &hash, .{});
    _ = std.fmt.bufPrint(out, "{}", .{std.fmt.fmtSliceHexLower(&hash)}) catch {};
}

fn mimeTypeFromPath(path: []const u8) []const u8 {
    if (std.mem.endsWith(u8, path, ".html")) return "text/html; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".css")) return "text/css; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".js")) return "application/javascript; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".json")) return "application/json";
    if (std.mem.endsWith(u8, path, ".png")) return "image/png";
    if (std.mem.endsWith(u8, path, ".jpg") or std.mem.endsWith(u8, path, ".jpeg")) return "image/jpeg";
    if (std.mem.endsWith(u8, path, ".gif")) return "image/gif";
    if (std.mem.endsWith(u8, path, ".svg")) return "image/svg+xml";
    if (std.mem.endsWith(u8, path, ".ico")) return "image/x-icon";
    if (std.mem.endsWith(u8, path, ".woff")) return "font/woff";
    if (std.mem.endsWith(u8, path, ".woff2")) return "font/woff2";
    return "application/octet-stream";
}

fn generateRoutesFile(allocator: std.mem.Allocator, routes: []const ProcessedRoute) !void {
    // Create output directory
    std.fs.cwd().makeDir("src/generated") catch |err| switch (err) {
        error.PathAlreadyExists => {},
        else => return err,
    };

    // Create the file
    const file = try std.fs.cwd().createFile("src/generated/routes.zig", .{});
    defer file.close();

    var writer = file.writer();

    // Write header
    try writer.writeAll(
        \\// AUTO-GENERATED by Orisha route collector
        \\// DO NOT EDIT - this file is regenerated at compile time
        \\
        \\const std = @import("std");
        \\
        \\pub const Route = struct {
        \\    method: []const u8,
        \\    path: []const u8,
        \\    content: []const u8,
        \\    content_length: usize,
        \\    etag: []const u8,
        \\    content_type: []const u8,
        \\};
        \\
        \\pub const routes = [_]Route{
        \\
    );

    // Write each route
    for (routes) |route| {
        try writer.print(
            \\    .{{
            \\        .method = "{s}",
            \\        .path = "{s}",
            \\        .content =
        , .{ route.method, route.path });

        // Write content as string literal or byte array
        if (isAsciiPrintable(route.content)) {
            try writeEscapedString(writer, route.content);
        } else {
            try writeByteArray(writer, route.content);
        }

        try writer.print(
            \\,
            \\        .content_length = {},
            \\        .etag = "\"{s}\"",
            \\        .content_type = "{s}",
            \\    }},
            \\
        , .{ route.content_length, route.etag[0..16], route.content_type });
    }

    // Write footer with lookup function
    try writer.writeAll(
        \\};
        \\
        \\pub fn lookup(method: []const u8, path: []const u8) ?Route {
        \\    for (routes) |route| {
        \\        if (std.mem.eql(u8, route.method, method) and std.mem.eql(u8, route.path, path)) {
        \\            return route;
        \\        }
        \\    }
        \\    return null;
        \\}
        \\
        \\pub fn formatResponse(route: Route) []const u8 {
        \\    // For now just return content - full HTTP response formatting in index.kz
        \\    return route.content;
        \\}
        \\
    );

    std.debug.print("Generated: src/generated/routes.zig\n", .{});
}

fn isAsciiPrintable(content: []const u8) bool {
    for (content) |c| {
        if (c < 0x20 or c > 0x7e) {
            if (c != '\n' and c != '\r' and c != '\t') return false;
        }
    }
    return true;
}

fn writeEscapedString(writer: anytype, content: []const u8) !void {
    try writer.writeAll("\"");
    for (content) |c| {
        switch (c) {
            '\n' => try writer.writeAll("\\n"),
            '\r' => try writer.writeAll("\\r"),
            '\t' => try writer.writeAll("\\t"),
            '"' => try writer.writeAll("\\\""),
            '\\' => try writer.writeAll("\\\\"),
            else => try writer.writeByte(c),
        }
    }
    try writer.writeAll("\"");
}

fn writeByteArray(writer: anytype, content: []const u8) !void {
    try writer.writeAll("&[_]u8{");
    for (content, 0..) |byte, i| {
        if (i > 0) try writer.writeAll(",");
        if (i % 16 == 0) try writer.writeAll("\n            ");
        try writer.print("0x{x:0>2}", .{byte});
    }
    try writer.writeAll("\n        }");
}
