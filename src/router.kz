// Router module - comptime route collection and manifest generation
//
// This module:
// 1. Walks the AST to find [norun] route declarations
// 2. Parses their Source block configs (JSON-like)
// 3. Reads file content for file routes
// 4. Computes SHA256 etags for cache validation
// 5. Generates src/generated/routes.zig with all processed routes

const std = @import("std");
const ast = @import("ast");
const Program = ast.Program;
const Sha256 = std.crypto.hash.sha2.Sha256;

// ============================================================================
// DATA STRUCTURES
// ============================================================================

const RouteConfig = struct {
    file: ?[]const u8 = null,
    body: ?[]const u8 = null,
    content_type: ?[]const u8 = null,
};

const ProcessedRoute = struct {
    method: []const u8,
    path: []const u8,
    content: []const u8,
    content_length: usize,
    etag: [64]u8,  // hex-encoded SHA256
    content_type: []const u8,
};

// ============================================================================
// COMPTIME EVENT
// ============================================================================

~[comptime] event collect_routes {
    program: *const Program,
    allocator: std.mem.Allocator
}
| done { route_count: usize }

~[comptime] proc collect_routes {
    std.debug.print("\n=== ORISHA ROUTE COLLECTOR ===\n", .{});
    std.debug.print("Walking AST ({} items)...\n\n", .{program.items.len});

    var routes: std.ArrayList(ProcessedRoute) = .empty;
    defer routes.deinit(allocator);

    // Walk AST looking for route invocations
    for (program.items) |item| {
        if (item != .flow) continue;
        const inv = item.flow.invocation;

        // Check if this is a "route" event
        if (inv.path.segments.len == 0) continue;
        const last_segment = inv.path.segments[inv.path.segments.len - 1];
        if (!std.mem.eql(u8, last_segment, "route")) continue;

        // Parse route expression: "GET /" -> method + path
        const route_expr_str = if (inv.args.len > 0) inv.args[0].value else continue;
        const route_expr = parseRouteExpr(route_expr_str);
        const method = route_expr.method;
        const path = route_expr.path;

        std.debug.print("Processing: {s} {s}\n", .{method, path});

        // Find and parse Source block config
        const config = parseSourceConfig(inv, allocator);

        // Process based on config type
        if (config.file) |file_path| {
            std.debug.print("  Reading file: {s}\n", .{file_path});
            const content = std.fs.cwd().readFileAlloc(allocator, file_path, 10 * 1024 * 1024) catch |err| {
                std.debug.print("  ERROR reading file: {}\n", .{err});
                continue;
            };

            var etag_buf: [64]u8 = undefined;
            computeEtag(content, &etag_buf);

            routes.append(allocator, .{
                .method = method,
                .path = path,
                .content = content,
                .content_length = content.len,
                .etag = etag_buf,
                .content_type = config.content_type orelse mimeTypeFromPath(file_path),
            }) catch continue;

            std.debug.print("  Content-Length: {}\n", .{content.len});
            std.debug.print("  ETag: \"{s}\"\n", .{etag_buf[0..16]});

        } else if (config.body) |body| {
            std.debug.print("  Inline body: {} bytes\n", .{body.len});

            var etag_buf: [64]u8 = undefined;
            computeEtag(body, &etag_buf);

            routes.append(allocator, .{
                .method = method,
                .path = path,
                .content = body,
                .content_length = body.len,
                .etag = etag_buf,
                .content_type = config.content_type orelse "text/plain",
            }) catch continue;
        }
    }

    std.debug.print("\n=== Generating routes.zig ({} routes) ===\n", .{routes.items.len});

    // Generate the routes.zig file
    generateRoutesFile(allocator, routes.items) catch |err| {
        std.debug.print("ERROR generating routes.zig: {}\n", .{err});
        return .{ .done = .{ .route_count = 0 } };
    };

    std.debug.print("=== Done! ===\n\n", .{});
    return .{ .done = .{ .route_count = routes.items.len } };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

const RouteExpr = struct {
    method: []const u8,
    path: []const u8,
};

fn parseRouteExpr(expr: []const u8) RouteExpr {
    // Parse "GET /path" -> ("GET", "/path")
    var iter = std.mem.tokenizeScalar(u8, expr, ' ');
    const method = iter.next() orelse "GET";
    const path = iter.next() orelse "/";
    return .{ .method = method, .path = path };
}

fn parseSourceConfig(inv: ast.Invocation, allocator: std.mem.Allocator) RouteConfig {
    var config = RouteConfig{};

    for (inv.args) |arg| {
        if (arg.source_value) |source| {
            // Parse JSON-like config: "key": "value"
            var lines = std.mem.splitScalar(u8, source.text, '\n');
            while (lines.next()) |line| {
                const trimmed = std.mem.trim(u8, line, " \t\r");
                if (trimmed.len == 0) continue;

                // Find "key": "value" pattern
                if (std.mem.indexOf(u8, trimmed, "\"file\"")) |_| {
                    config.file = extractQuotedValue(trimmed, allocator);
                } else if (std.mem.indexOf(u8, trimmed, "\"body\"")) |_| {
                    config.body = extractQuotedValue(trimmed, allocator);
                } else if (std.mem.indexOf(u8, trimmed, "\"content-type\"")) |_| {
                    config.content_type = extractQuotedValue(trimmed, allocator);
                }
            }
        }
    }

    return config;
}

fn extractQuotedValue(line: []const u8, allocator: std.mem.Allocator) ?[]const u8 {
    // Find the value in: "key": "value" or "key": "value",
    // Look for the colon, then find the quoted value after it
    const colon_pos = std.mem.indexOf(u8, line, ":") orelse return null;
    const after_colon = line[colon_pos + 1..];

    // Find first quote after colon
    const first_quote = std.mem.indexOf(u8, after_colon, "\"") orelse return null;
    const value_start = after_colon[first_quote + 1..];

    // Find closing quote (handle escaped quotes later if needed)
    const end_quote = std.mem.indexOf(u8, value_start, "\"") orelse return null;

    // Duplicate the string so it persists
    return allocator.dupe(u8, value_start[0..end_quote]) catch null;
}

fn computeEtag(content: []const u8, out: *[64]u8) void {
    var hash: [32]u8 = undefined;
    Sha256.hash(content, &hash, .{});
    // Manual hex encoding
    const hex_chars = "0123456789abcdef";
    for (hash, 0..) |byte, i| {
        out[i * 2] = hex_chars[byte >> 4];
        out[i * 2 + 1] = hex_chars[byte & 0x0f];
    }
}

fn mimeTypeFromPath(path: []const u8) []const u8 {
    if (std.mem.endsWith(u8, path, ".html")) return "text/html; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".css")) return "text/css; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".js")) return "application/javascript; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".json")) return "application/json";
    if (std.mem.endsWith(u8, path, ".png")) return "image/png";
    if (std.mem.endsWith(u8, path, ".jpg") or std.mem.endsWith(u8, path, ".jpeg")) return "image/jpeg";
    if (std.mem.endsWith(u8, path, ".gif")) return "image/gif";
    if (std.mem.endsWith(u8, path, ".svg")) return "image/svg+xml";
    if (std.mem.endsWith(u8, path, ".ico")) return "image/x-icon";
    if (std.mem.endsWith(u8, path, ".woff")) return "font/woff";
    if (std.mem.endsWith(u8, path, ".woff2")) return "font/woff2";
    return "application/octet-stream";
}

fn generateRoutesFile(allocator: std.mem.Allocator, routes: []const ProcessedRoute) !void {
    // Create output directory (relative to cwd which is src/)
    std.fs.cwd().makeDir("generated") catch |err| switch (err) {
        error.PathAlreadyExists => {},
        else => return err,
    };

    // Build content in memory using ArrayList
    var output: std.ArrayList(u8) = .empty;
    defer output.deinit(allocator);

    // Write header
    try output.appendSlice(allocator,
        \\// AUTO-GENERATED by Orisha route collector
        \\// DO NOT EDIT - this file is regenerated at compile time
        \\
        \\const std = @import("std");
        \\
        \\pub const Route = struct {
        \\    method: []const u8,
        \\    path: []const u8,
        \\    content: []const u8,
        \\    content_length: usize,
        \\    etag: []const u8,
        \\    content_type: []const u8,
        \\};
        \\
        \\pub const routes = [_]Route{
        \\
    );

    // Write each route
    for (routes) |route| {
        // Route header
        try appendFmt(allocator, &output, "    .{{\n        .method = \"{s}\",\n        .path = \"{s}\",\n        .content = ", .{ route.method, route.path });

        // Content as escaped string
        try output.append(allocator, '"');
        for (route.content) |c| {
            switch (c) {
                '\n' => try output.appendSlice(allocator, "\\n"),
                '\r' => try output.appendSlice(allocator, "\\r"),
                '\t' => try output.appendSlice(allocator, "\\t"),
                '"' => try output.appendSlice(allocator, "\\\""),
                '\\' => try output.appendSlice(allocator, "\\\\"),
                else => try output.append(allocator, c),
            }
        }
        try output.append(allocator, '"');

        // Route footer
        try appendFmt(allocator, &output, ",\n        .content_length = {},\n        .etag = \"\\\"{s}\\\"\",\n        .content_type = \"{s}\",\n    }},\n", .{ route.content_length, route.etag[0..16], route.content_type });
    }

    // Write footer
    try output.appendSlice(allocator,
        \\};
        \\
        \\pub fn lookup(method: []const u8, path: []const u8) ?Route {
        \\    for (routes) |route| {
        \\        if (std.mem.eql(u8, route.method, method) and std.mem.eql(u8, route.path, path)) {
        \\            return route;
        \\        }
        \\    }
        \\    return null;
        \\}
        \\
    );

    // Write to file
    const file = try std.fs.cwd().createFile("generated/routes.zig", .{});
    defer file.close();
    try file.writeAll(output.items);

    std.debug.print("Generated: src/generated/routes.zig ({} bytes)\n", .{output.items.len});
}

fn appendFmt(allocator: std.mem.Allocator, list: *std.ArrayList(u8), comptime fmt: []const u8, args: anytype) !void {
    var buf: [4096]u8 = undefined;
    const slice = std.fmt.bufPrint(&buf, fmt, args) catch return error.OutOfMemory;
    try list.appendSlice(allocator, slice);
}
