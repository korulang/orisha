// Router module - comptime route collection and manifest generation
//
// This module:
// 1. Walks the AST to find [norun] route declarations
// 2. Parses their Source block configs (JSON-like)
// 3. Reads file content for file routes
// 4. Computes SHA256 etags for cache validation
// 5. Generates src/generated/routes.zig with all processed routes

const std = @import("std");
const ast = @import("ast");
const Program = ast.Program;
const Sha256 = std.crypto.hash.sha2.Sha256;

// ============================================================================
// DATA STRUCTURES
// ============================================================================

const RouteConfig = struct {
    file: ?[]const u8 = null,
    body: ?[]const u8 = null,
    content_type: ?[]const u8 = null,
    directory: ?[]const u8 = null,
};

const ProcessedRoute = struct {
    method: []const u8,
    path: []const u8,
    response: []const u8,  // Complete HTTP response: headers + body as ONE BLOB
    etag: []const u8,      // Just the ETag value (for If-None-Match comparison)
};

// ============================================================================
// COMPTIME EVENT
// ============================================================================

~[comptime] event collect_routes {
    program: *const Program,
    allocator: std.mem.Allocator
}
| done { route_count: usize }

~[comptime] proc collect_routes {
    std.debug.print("\n=== ORISHA ROUTE COLLECTOR ===\n", .{});
    std.debug.print("Walking AST ({} items)...\n\n", .{program.items.len});

    var routes: std.ArrayList(ProcessedRoute) = .empty;
    defer routes.deinit(allocator);

    // Walk AST looking for route invocations
    for (program.items) |item| {
        if (item != .flow) continue;
        const inv = item.flow.invocation;

        // Check if this is a "route" event
        if (inv.path.segments.len == 0) continue;
        const last_segment = inv.path.segments[inv.path.segments.len - 1];
        if (!std.mem.eql(u8, last_segment, "route")) continue;

        // Parse route expression: "GET /" -> method + path
        const route_expr_str = if (inv.args.len > 0) inv.args[0].value else continue;
        const route_expr = parseRouteExpr(route_expr_str);
        const method = route_expr.method;
        const path = route_expr.path;

        std.debug.print("Processing: {s} {s}\n", .{method, path});

        // Find and parse Source block config
        const config = parseSourceConfig(inv, allocator);

        // Process based on config type
        if (config.directory) |dir_path| {
            std.debug.print("  Walking directory: {s}\n", .{dir_path});

            // Walk directory recursively and add routes for each file
            var dir = std.fs.cwd().openDir(dir_path, .{ .iterate = true }) catch |err| {
                std.debug.print("  ERROR opening directory: {}\n", .{err});
                continue;
            };
            defer dir.close();

            var walker = dir.walk(allocator) catch |err| {
                std.debug.print("  ERROR walking directory: {}\n", .{err});
                continue;
            };
            defer walker.deinit();

            while (walker.next() catch null) |entry| {
                if (entry.kind != .file) continue;

                // Build file path relative to cwd
                const file_path = std.fmt.allocPrint(allocator, "{s}/{s}", .{ dir_path, entry.path }) catch continue;

                // Build route path: base_path + file_path (strip leading slash if present)
                const route_path = if (std.mem.eql(u8, path, "/"))
                    std.fmt.allocPrint(allocator, "/{s}", .{entry.path}) catch continue
                else
                    std.fmt.allocPrint(allocator, "{s}/{s}", .{ path, entry.path }) catch continue;

                std.debug.print("    Route: {s} -> {s}\n", .{ route_path, file_path });

                const content = std.fs.cwd().readFileAlloc(allocator, file_path, 10 * 1024 * 1024) catch |err| {
                    std.debug.print("    ERROR reading file: {}\n", .{err});
                    continue;
                };

                const content_type = mimeTypeFromPath(file_path);
                const http_resp = buildHttpResponse(allocator, content, content_type) catch continue;

                routes.append(allocator, .{
                    .method = method,
                    .path = route_path,
                    .response = http_resp.response,
                    .etag = http_resp.etag,
                }) catch continue;
            }

        } else if (config.file) |file_path| {
            std.debug.print("  Reading file: {s}\n", .{file_path});
            const content = std.fs.cwd().readFileAlloc(allocator, file_path, 10 * 1024 * 1024) catch |err| {
                std.debug.print("  ERROR reading file: {}\n", .{err});
                continue;
            };

            const content_type = config.content_type orelse mimeTypeFromPath(file_path);
            const http_resp = buildHttpResponse(allocator, content, content_type) catch continue;

            routes.append(allocator, .{
                .method = method,
                .path = path,
                .response = http_resp.response,
                .etag = http_resp.etag,
            }) catch continue;

            std.debug.print("  Response blob: {} bytes\n", .{http_resp.response.len});

        } else if (config.body) |body| {
            std.debug.print("  Inline body: {} bytes\n", .{body.len});

            const content_type = config.content_type orelse "text/plain";
            const http_resp = buildHttpResponse(allocator, body, content_type) catch continue;

            routes.append(allocator, .{
                .method = method,
                .path = path,
                .response = http_resp.response,
                .etag = http_resp.etag,
            }) catch continue;

            std.debug.print("  Response blob: {} bytes\n", .{http_resp.response.len});
        }
    }

    std.debug.print("\n=== Generating routes.zig ({} routes) ===\n", .{routes.items.len});

    // Generate the routes.zig file
    generateRoutesFile(allocator, routes.items) catch |err| {
        std.debug.print("ERROR generating routes.zig: {}\n", .{err});
        return .{ .done = .{ .route_count = 0 } };
    };

    std.debug.print("=== Done! ===\n\n", .{});
    return .{ .done = .{ .route_count = routes.items.len } };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

const RouteExpr = struct {
    method: []const u8,
    path: []const u8,
};

fn parseRouteExpr(expr: []const u8) RouteExpr {
    // Parse "GET /path" -> ("GET", "/path")
    var iter = std.mem.tokenizeScalar(u8, expr, ' ');
    const method = iter.next() orelse "GET";
    const path = iter.next() orelse "/";
    return .{ .method = method, .path = path };
}

fn parseSourceConfig(inv: ast.Invocation, allocator: std.mem.Allocator) RouteConfig {
    var config = RouteConfig{};

    for (inv.args) |arg| {
        if (arg.source_value) |source| {
            // Parse JSON-like config: "key": "value"
            var lines = std.mem.splitScalar(u8, source.text, '\n');
            while (lines.next()) |line| {
                const trimmed = std.mem.trim(u8, line, " \t\r");
                if (trimmed.len == 0) continue;

                // Find "key": "value" pattern
                if (std.mem.indexOf(u8, trimmed, "\"file\"")) |_| {
                    config.file = extractQuotedValue(trimmed, allocator);
                } else if (std.mem.indexOf(u8, trimmed, "\"body\"")) |_| {
                    config.body = extractQuotedValue(trimmed, allocator);
                } else if (std.mem.indexOf(u8, trimmed, "\"content-type\"")) |_| {
                    config.content_type = extractQuotedValue(trimmed, allocator);
                } else if (std.mem.indexOf(u8, trimmed, "\"directory\"")) |_| {
                    config.directory = extractQuotedValue(trimmed, allocator);
                }
            }
        }
    }

    return config;
}

fn extractQuotedValue(line: []const u8, allocator: std.mem.Allocator) ?[]const u8 {
    // Find the value in: "key": "value" or "key": "value",
    // Look for the colon, then find the quoted value after it
    const colon_pos = std.mem.indexOf(u8, line, ":") orelse return null;
    const after_colon = line[colon_pos + 1..];

    // Find first quote after colon
    const first_quote = std.mem.indexOf(u8, after_colon, "\"") orelse return null;
    const value_start = after_colon[first_quote + 1..];

    // Find closing quote (handle escaped quotes later if needed)
    const end_quote = std.mem.indexOf(u8, value_start, "\"") orelse return null;

    // Duplicate the string so it persists
    return allocator.dupe(u8, value_start[0..end_quote]) catch null;
}

fn computeEtag(content: []const u8, out: *[64]u8) void {
    var hash: [32]u8 = undefined;
    Sha256.hash(content, &hash, .{});
    // Manual hex encoding
    const hex_chars = "0123456789abcdef";
    for (hash, 0..) |byte, i| {
        out[i * 2] = hex_chars[byte >> 4];
        out[i * 2 + 1] = hex_chars[byte & 0x0f];
    }
}

const HttpResponse = struct {
    response: []const u8,
    etag: []const u8,
};

fn buildHttpResponse(allocator: std.mem.Allocator, content: []const u8, content_type: []const u8) !HttpResponse {
    // Compute etag
    var etag_buf: [64]u8 = undefined;
    computeEtag(content, &etag_buf);
    const etag = try allocator.dupe(u8, etag_buf[0..16]);  // First 16 chars of hash

    // Build complete HTTP response: headers + body as ONE BLOB
    var response: std.ArrayList(u8) = .empty;
    errdefer response.deinit(allocator);

    // Status line
    try response.appendSlice(allocator, "HTTP/1.1 200 OK\r\n");

    // Headers
    try response.appendSlice(allocator, "Content-Type: ");
    try response.appendSlice(allocator, content_type);
    try response.appendSlice(allocator, "\r\n");

    try response.appendSlice(allocator, "Content-Length: ");
    var len_buf: [20]u8 = undefined;
    const len_str = std.fmt.bufPrint(&len_buf, "{}", .{content.len}) catch "0";
    try response.appendSlice(allocator, len_str);
    try response.appendSlice(allocator, "\r\n");

    try response.appendSlice(allocator, "ETag: \"");
    try response.appendSlice(allocator, etag);
    try response.appendSlice(allocator, "\"\r\n");

    try response.appendSlice(allocator, "Connection: keep-alive\r\n");
    try response.appendSlice(allocator, "\r\n");

    // Body
    try response.appendSlice(allocator, content);

    return .{ .response = response.items, .etag = etag };
}

fn mimeTypeFromPath(path: []const u8) []const u8 {
    if (std.mem.endsWith(u8, path, ".html")) return "text/html; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".css")) return "text/css; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".js")) return "application/javascript; charset=utf-8";
    if (std.mem.endsWith(u8, path, ".json")) return "application/json";
    if (std.mem.endsWith(u8, path, ".png")) return "image/png";
    if (std.mem.endsWith(u8, path, ".jpg") or std.mem.endsWith(u8, path, ".jpeg")) return "image/jpeg";
    if (std.mem.endsWith(u8, path, ".gif")) return "image/gif";
    if (std.mem.endsWith(u8, path, ".svg")) return "image/svg+xml";
    if (std.mem.endsWith(u8, path, ".ico")) return "image/x-icon";
    if (std.mem.endsWith(u8, path, ".woff")) return "font/woff";
    if (std.mem.endsWith(u8, path, ".woff2")) return "font/woff2";
    return "application/octet-stream";
}

fn generateRoutesFile(allocator: std.mem.Allocator, routes: []const ProcessedRoute) !void {
    // Create output directory (relative to cwd which is src/)
    std.fs.cwd().makeDir("generated") catch |err| switch (err) {
        error.PathAlreadyExists => {},
        else => return err,
    };

    // Build content in memory using ArrayList
    var output: std.ArrayList(u8) = .empty;
    defer output.deinit(allocator);

    // Write header
    try output.appendSlice(allocator,
        \\// AUTO-GENERATED by Orisha route collector
        \\// DO NOT EDIT - this file is regenerated at compile time
        \\//
        \\// Each route contains a COMPLETE HTTP response blob:
        \\// headers + body pre-computed at compile time.
        \\// Just writeAll() to the socket. ZERO runtime formatting.
        \\
        \\const std = @import("std");
        \\
        \\pub const Route = struct {
        \\    method: []const u8,
        \\    path: []const u8,
        \\    response: []const u8,  // Complete HTTP response: status + headers + body
        \\    etag: []const u8,      // ETag value for If-None-Match comparison
        \\};
        \\
        \\// Pre-computed 304 Not Modified response (same for all routes)
        \\pub const response_304 = "HTTP/1.1 304 Not Modified\r\nConnection: keep-alive\r\n\r\n";
        \\
        \\pub const routes = [_]Route{
        \\
    );

    // Write each route
    for (routes) |route| {
        // Route header
        try appendFmt(allocator, &output, "    .{{\n        .method = \"{s}\",\n        .path = \"{s}\",\n        .etag = \"{s}\",\n        .response = ", .{ route.method, route.path, route.etag });

        // Response blob as escaped string
        try output.append(allocator, '"');
        for (route.response) |c| {
            switch (c) {
                '\n' => try output.appendSlice(allocator, "\\n"),
                '\r' => try output.appendSlice(allocator, "\\r"),
                '\t' => try output.appendSlice(allocator, "\\t"),
                '"' => try output.appendSlice(allocator, "\\\""),
                '\\' => try output.appendSlice(allocator, "\\\\"),
                else => try output.append(allocator, c),
            }
        }
        try output.append(allocator, '"');

        try output.appendSlice(allocator, ",\n    },\n");
    }

    // Write footer
    try output.appendSlice(allocator,
        \\};
        \\
        \\/// Lookup route and return complete HTTP response blob.
        \\/// Just writeAll() the result - no formatting needed!
        \\pub fn lookup(method: []const u8, path: []const u8) ?[]const u8 {
        \\    for (routes) |route| {
        \\        if (std.mem.eql(u8, route.method, method) and std.mem.eql(u8, route.path, path)) {
        \\            return route.response;
        \\        }
        \\    }
        \\    return null;
        \\}
        \\
        \\/// Lookup route with If-None-Match support.
        \\/// If client_etag matches, returns 304 response. Otherwise returns full response.
        \\/// Returns null if route not found.
        \\pub fn lookupWithEtag(method: []const u8, path: []const u8, client_etag: ?[]const u8) ?[]const u8 {
        \\    for (routes) |route| {
        \\        if (std.mem.eql(u8, route.method, method) and std.mem.eql(u8, route.path, path)) {
        \\            // Check If-None-Match
        \\            if (client_etag) |etag| {
        \\                if (std.mem.eql(u8, etag, route.etag)) {
        \\                    return response_304;
        \\                }
        \\            }
        \\            return route.response;
        \\        }
        \\    }
        \\    return null;
        \\}
        \\
    );

    // Write to file
    const file = try std.fs.cwd().createFile("generated/routes.zig", .{});
    defer file.close();
    try file.writeAll(output.items);

    std.debug.print("Generated: src/generated/routes.zig ({} bytes)\n", .{output.items.len});
}

fn appendFmt(allocator: std.mem.Allocator, list: *std.ArrayList(u8), comptime fmt: []const u8, args: anytype) !void {
    var buf: [4096]u8 = undefined;
    const slice = std.fmt.bufPrint(&buf, fmt, args) catch return error.OutOfMemory;
    try list.appendSlice(allocator, slice);
}
