// Orisha Dynamic Server Benchmark
//
// Handles both static files and dynamic API endpoints.
// Static: / (embedded HTML)
// Dynamic: /api/users/:id, /api/health
//
// Run: koruc main.kz && ./a.out

~import "$orisha"
~import "$std/build"

const std = @import("std");

// ============================================================================
// STATIC CONTENT (compile-time embedded)
// ============================================================================

~orisha:static(path: "/", directory: "public")

~orisha:collect_routes()
| done |> _

const static_routes = @import("generated/routes.zig");

// ============================================================================
// DYNAMIC ROUTING
// ============================================================================

// Pre-computed response for /api/health (it's constant)
const health_response = "HTTP/1.1 200 OK\r\n" ++
    "Content-Type: application/json\r\n" ++
    "Content-Length: 15\r\n" ++
    "Connection: keep-alive\r\n\r\n" ++
    "{\"status\":\"ok\"}";

// Combined router: static lookup + dynamic patterns
fn combinedRouter(method: []const u8, path: []const u8, client_etag: ?[]const u8) ?[]const u8 {
    // 1. Try static routes first (O(n) for now, could be hash)
    if (static_routes.lookupWithEtag(method, path, client_etag)) |response| {
        return response;
    }

    // 2. Dynamic patterns
    if (std.mem.eql(u8, method, "GET")) {
        // /api/health - constant response
        if (std.mem.eql(u8, path, "/api/health")) {
            return health_response;
        }

        // /api/users/:id - dynamic response
        if (path.len > 11 and std.mem.startsWith(u8, path, "/api/users/")) {
            const id = path[11..];
            // Validate: no more slashes (it's the final segment)
            if (std.mem.indexOf(u8, id, "/") == null and id.len > 0) {
                return buildUserResponse(id);
            }
        }
    }

    return null;
}

// Build JSON response for /api/users/:id
// Uses thread-local buffer to avoid allocation
fn buildUserResponse(id: []const u8) []const u8 {
    const S = struct {
        threadlocal var buf: [512]u8 = undefined;
    };

    // Calculate body length: {"id":"<id>","name":"User <id>"}
    // Base: {"id":"","name":"User "} = 24 chars + 2*id.len
    const body_len = 24 + id.len * 2;

    const response = std.fmt.bufPrint(&S.buf,
        "HTTP/1.1 200 OK\r\n" ++
        "Content-Type: application/json\r\n" ++
        "Content-Length: {d}\r\n" ++
        "Connection: keep-alive\r\n\r\n" ++
        "{{\"id\":\"{s}\",\"name\":\"User {s}\"}}",
        .{ body_len, id, id }
    ) catch return "HTTP/1.1 500 Internal Server Error\r\nContent-Length: 0\r\n\r\n";

    return response;
}

// ============================================================================
// SERVER
// ============================================================================

~orisha:serve(port: 3000, router: combinedRouter)
| listening |> _
| failed |> _
