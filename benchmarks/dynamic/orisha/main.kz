// Orisha Dynamic Benchmark - Using the Router DSL
//
// Tests the ~orisha:router pattern-matching syntax with a real server
// Endpoints: /plaintext, /json, /api/health, /api/users/:id
//
// Run: koruc main.kz && ./a.out

~import "$orisha"
const std = @import("std");

// Build JSON body for /api/users/:id (upstream formatting)
fn userJsonBody(id: []const u8) []const u8 {
    const S = struct {
        threadlocal var buf: [256]u8 = undefined;
    };

    return std.fmt.bufPrint(&S.buf, "{{\"id\":\"{s}\",\"name\":\"User {s}\"}}", .{ id, id }) catch id;
}

// Implement the handler as a subflow with router
~orisha:handler = orisha:router(req)
// Log-guided order based on access.log (most frequent first)
| [GET /api/users/:id] p |> response { status: 200, body: main_module.userJsonBody(p.id), content_type: "application/json" }
| [GET /json] |> response { status: 200, body: "{\"message\":\"Hello, World!\"}", content_type: "application/json" }
| [GET /api/health] |> response { status: 200, body: "{\"status\":\"ok\"}", content_type: "application/json" }
| [GET /plaintext] |> response { status: 200, body: "Hello, World!", content_type: "text/plain" }
| [*] |> response { status: 404, body: "Not Found", content_type: "text/plain" }

// Start the server
~orisha:serve(port: 3000)
| shutdown _ |> _
| failed _ |> _
